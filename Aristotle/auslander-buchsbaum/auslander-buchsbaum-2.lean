/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 88f2b498-12b9-4817-834d-f8f5763970f4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d9c86a8e-b0e8-4506-826b-48c3583c3a3f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking for IsLocalRing.ResidueField and IsLocalRing.CotangentSpace.
-/
#check IsLocalRing.ResidueField
#check IsLocalRing.CotangentSpace

/-
Checking instances and types for the definition of regular local ring.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R]
#synth Field (IsLocalRing.ResidueField R)
#synth Module (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)
#check (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) : WithBot ℕ∞)

/-
Definition of a regular local ring.
-/
/-- A regular local ring is a Noetherian local ring such that the Krull dimension is equal to the dimension of the cotangent space. -/
def IsRegularLocalRing (R : Type*) [CommRing R] [IsLocalRing R] : Prop :=
  IsNoetherianRing R ∧
  ringKrullDim R = (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) : WithBot ℕ∞)

/-
A regular local ring of dimension zero is a field.
-/
lemma regular_local_ring_dim_zero_is_field (R : Type*) [CommRing R] [IsLocalRing R] (h : IsRegularLocalRing R) (h_dim : ringKrullDim R = 0) : IsField R := by
  obtain ⟨ h1, h2 ⟩ := h; (
  have h_cotangent_space_zero : Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) = 0 := by
    aesop;
  exact?);

/-
If a regular local ring has positive dimension, there exists an element in the maximal ideal but not in its square.
-/
lemma exists_regular_param (R : Type*) [CommRing R] [IsLocalRing R] (h : IsRegularLocalRing R) (h_dim : ringKrullDim R > 0) :
    ∃ x ∈ IsLocalRing.maximalIdeal R, x ∉ IsLocalRing.maximalIdeal R ^ 2 := by
  -- Since $R$ is a regular local ring, its maximal ideal is finitely generated.
  have h_fg : (IsNoetherianRing R) := by
    exact h.1;
  by_contra! h_contra;
  -- If $M = M^2$, then by Nakayama's lemma, $M = 0$.
  have h_nakayama : IsLocalRing.maximalIdeal R = 0 := by
    apply Submodule.eq_bot_of_le_smul_of_le_jacobson_bot;
    exacts [ IsNoetherian.noetherian _, fun x hx => by simpa [ sq ] using h_contra x hx, by simp +decide [ IsLocalRing.jacobson_eq_maximalIdeal ] ];
  -- If $M = 0$, then $R$ is a field.
  have h_field : IsField R := by
    exact?;
  -- If $R$ is a field, then its Krull dimension is zero.
  have h_krull_zero : ringKrullDim R = 0 := by
    exact?;
  exact h_dim.ne' h_krull_zero

/-
The quotient of a local ring by a proper ideal is a local ring.
-/
instance isLocalRing_quotient_of_proper_ideal (R : Type*) [CommRing R] [IsLocalRing R] (I : Ideal R) (h : I ≠ ⊤) : IsLocalRing (R ⧸ I) := by
  refine' { .. };
  · refine' ⟨ 0, 1, _ ⟩;
    exact?;
  · rintro a b hab;
    obtain ⟨ x, rfl ⟩ := Ideal.Quotient.mk_surjective a; obtain ⟨ y, rfl ⟩ := Ideal.Quotient.mk_surjective b; simp_all +decide [ Ideal.Quotient.eq ] ;
    -- Since $x + y = 1$, we have $1 - x = y$. If $x$ is not a unit, then $1 - x$ must be a unit.
    have h_unit : ¬IsUnit x → IsUnit (1 - x) := by
      exact?;
    by_cases hx : IsUnit x <;> simp_all +decide [ ← eq_sub_iff_add_eq' ];
    · exact Or.inl ( IsUnit.map ( Ideal.Quotient.mk I ) hx );
    · exact Or.inr ( by simpa using h_unit.map ( Ideal.Quotient.mk I ) )

/-
The quotient of a local ring by the ideal generated by an element in the maximal ideal is a local ring.
-/
instance isLocalRing_quotient_span_singleton (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx : x ∈ IsLocalRing.maximalIdeal R) : IsLocalRing (R ⧸ Ideal.span {x}) := by
  have h_local_quotient : ∀ (I : Ideal R), I ≠ ⊤ → IsLocalRing (R ⧸ I) := by
    exact?;
  by_cases h : Ideal.span { x } = ⊤ <;> aesop

/-
If the quotient by an element is a domain, then the element is prime.
-/
lemma prime_of_quotient_domain (R : Type*) [CommRing R] (x : R) (h : IsDomain (R ⧸ Ideal.span {x})) (hx : x ≠ 0) : Prime x := by
  rw [ ← Ideal.span_singleton_prime hx ];
  exact?

/-
The dimension of the quotient of a finite-dimensional vector space by a non-zero vector drops by 1.
-/
lemma finrank_quotient_span_singleton {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (v : V) (hv : v ≠ 0) :
    Module.finrank K (V ⧸ Submodule.span K {v}) + 1 = Module.finrank K V := by
  have := Submodule.finrank_quotient_add_finrank ( Submodule.span K { v } );
  rw [ ← this, finrank_span_singleton hv ]

/-
Definition of embedding dimension.
-/
/-- The embedding dimension of a local ring is the dimension of its cotangent space. -/
def embeddingDim (R : Type*) [CommRing R] [IsLocalRing R] : ℕ :=
  Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)

/-
Checking availability of definitions.
-/
#check embeddingDim
#check IsRegularLocalRing

/-
The image of an element in m \ m^2 is non-zero in the cotangent space.
-/
lemma to_cotangent_ne_zero (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) (hx_not_mem_sq : x ∉ IsLocalRing.maximalIdeal R ^ 2) :
    Ideal.toCotangent (IsLocalRing.maximalIdeal R) ⟨x, hx_mem⟩ ≠ 0 := by
  intro h;
  erw [ Submodule.Quotient.mk_eq_zero ] at h;
  simp_all +decide [ Submodule.mem_smul_top_iff ];
  exact hx_not_mem_sq ( by simpa only [ sq ] using h )

/-
The residue field of a quotient of a local ring is isomorphic to the residue field of the ring.
-/
def residueFieldQuotientIso (R : Type*) [CommRing R] [IsLocalRing R] (I : Ideal R) (hI : I ≠ ⊤) :
    @IsLocalRing.ResidueField (R ⧸ I) _ (isLocalRing_quotient_of_proper_ideal R I hI) ≃+* IsLocalRing.ResidueField R := by
  let R' := R ⧸ I
  haveI := isLocalRing_quotient_of_proper_ideal R I hI
  let m := IsLocalRing.maximalIdeal R
  let m' := IsLocalRing.maximalIdeal R'
  let f : R' →+* IsLocalRing.ResidueField R := Ideal.Quotient.lift I (Ideal.Quotient.mk m) (fun x hx => Ideal.Quotient.eq_zero_iff_mem.mpr (IsLocalRing.le_maximalIdeal hI hx))
  let g : IsLocalRing.ResidueField R' →+* IsLocalRing.ResidueField R := Ideal.Quotient.lift m' f (by
  simp +zetaDelta at *;
  intro a ha
  generalize_proofs at *;
  obtain ⟨ x, rfl ⟩ := Ideal.Quotient.mk_surjective a;
  contrapose! ha;
  -- Since $x \notin m$, $x$ is a unit in $R$.
  have hx_unit : IsUnit x := by
    exact?;
  exact hx_unit.map ( Ideal.Quotient.mk I ))
  apply RingEquiv.ofBijective g (by
  refine' ⟨ _, _ ⟩;
  · exact?;
  · intro x;
    obtain ⟨ y, hy ⟩ := Ideal.Quotient.mk_surjective x;
    exact ⟨ Ideal.Quotient.mk m' ( Ideal.Quotient.mk I y ), by aesop ⟩)

/-
Definition of the submodule generated by a regular parameter in the cotangent space.
-/
def regularParamSubmodule (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx : x ∈ IsLocalRing.maximalIdeal R) :
    Submodule (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) :=
  Submodule.span (IsLocalRing.ResidueField R) {Ideal.toCotangent (IsLocalRing.maximalIdeal R) ⟨x, hx⟩}

/-
The dimension of the submodule generated by a regular parameter is 1.
-/
lemma finrank_regular_param_submodule_eq_one (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) (hx_not_mem_sq : x ∉ IsLocalRing.maximalIdeal R ^ 2) :
    Module.finrank (IsLocalRing.ResidueField R) (regularParamSubmodule R x hx_mem) = 1 := by
  convert finrank_span_singleton _;
  exact?

/-
Checking if residueFieldQuotientIso is available.
-/
#check residueFieldQuotientIso

/-
Checking if AddCommGroup instance is available for the quotient of the cotangent space.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R)
#synth AddCommGroup ((IsLocalRing.CotangentSpace R) ⧸ (regularParamSubmodule R x hx_mem))

/-
Increasing the heartbeat limit for typeclass synthesis.
-/


/-
Defining the quotient of the cotangent space by the regular parameter submodule.
-/
def CotangentQuotient (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) : Type _ :=
  (IsLocalRing.CotangentSpace R) ⧸ (regularParamSubmodule R x hx_mem)

/-
Checking instances for CotangentSpace.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R]
#synth AddCommGroup (IsLocalRing.CotangentSpace R)
#synth Module (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)

/-
Checking if AddCommGroup instance is available for a generic quotient of the cotangent space.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R] (S : Submodule (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R))
#synth AddCommGroup ((IsLocalRing.CotangentSpace R) ⧸ S)

/-
Defining an abbreviation for the quotient of the cotangent space.
-/
abbrev CotangentQuotientAbbrev (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :=
  (IsLocalRing.CotangentSpace R) ⧸ (regularParamSubmodule R x hx_mem)

/-
Adding AddCommGroup instance for CotangentQuotient.
-/
instance (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    AddCommGroup (CotangentQuotient R x hx_mem) :=
  Submodule.Quotient.addCommGroup (regularParamSubmodule R x hx_mem)

/-
Adding Module instance for CotangentQuotient.
-/
instance (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    Module (IsLocalRing.ResidueField R) (CotangentQuotient R x hx_mem) :=
  Submodule.Quotient.module (regularParamSubmodule R x hx_mem)

/-
Checking the definition of CotangentSpace.
-/
#print IsLocalRing.CotangentSpace

/-
Adding IsLocalHom instance for the quotient map.
-/
instance (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
  IsLocalHom (Ideal.Quotient.mk (Ideal.span {x})) :=
  isLocalHom_of_le_jacobson_bot _ (by
  simp +decide [ Ideal.span_singleton_le_iff_mem, hx_mem ];
  -- Since the ideal is the bottom ideal, which is 0, the Jacobson radical of 0 is just the intersection of all maximal ideals. But since we're dealing with a local ring, there's only one maximal ideal, which is the maximal ideal of R. Therefore, x must be in that maximal ideal, which is exactly hx_mem. So the conclusion follows directly from hx_mem.
  simp [Ideal.jacobson];
  intro p hp;
  have h_max_eq : p = IsLocalRing.maximalIdeal R := by
    exact?;
  aesop)

/-
Checking the existence and type of Ideal.span_singleton_le_iff_mem.
-/
#check Ideal.span_singleton_le_iff_mem

/-
Adding IsLocalHom instance for the quotient map.
-/
instance (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
  IsLocalHom (Ideal.Quotient.mk (Ideal.span {x})) :=
  isLocalHom_of_le_jacobson_bot _ (by
  simp +decide [ Ideal.jacobson, hx_mem ];
  -- Since the maximal ideal is the unique maximal ideal in a local ring, any maximal ideal must be the same as the maximal ideal.
  have h_max_ideal : ∀ (b : Ideal R), b.IsMaximal → b = IsLocalRing.maximalIdeal R := by
    exact?;
  exact fun b hb => h_max_ideal b hb ▸ Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hx_mem ))

/-
Defining the function underlying the map between maximal ideals.
-/
noncomputable def maximalIdealMapFun (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    IsLocalRing.maximalIdeal R → @IsLocalRing.maximalIdeal (R ⧸ Ideal.span {x}) _ (isLocalRing_quotient_span_singleton R x hx_mem) :=
    fun y => ⟨Ideal.Quotient.mk (Ideal.span {x}) y.1, by
      intro hy;
      obtain ⟨ u, hu ⟩ := hy.exists_right_inv;
      obtain ⟨ z, hz ⟩ := Ideal.Quotient.mk_surjective u;
      -- Since $y \in \text{maximalIdeal } R$ and $z \in R$, their product $y * z$ is also in $\text{maximalIdeal } R$.
      have h_prod : y.val * z ∈ IsLocalRing.maximalIdeal R := by
        exact Ideal.mul_mem_right _ _ y.2;
      have h_contra : 1 - y.val * z ∈ Ideal.span {x} := by
        rw [ ← Ideal.Quotient.eq_zero_iff_mem ] at * ; aesop;
      have h_contra : 1 - y.val * z ∈ IsLocalRing.maximalIdeal R := by
        exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hx_mem ) h_contra;
      exact absurd ( Ideal.add_mem _ h_contra h_prod ) ( by simp +decide [ IsLocalRing.mem_maximalIdeal ] )
    ⟩

/-
Defining the linear map between maximal ideals.
-/
noncomputable def maximalIdealMap (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    let I := Ideal.span {x}
    let h_local := isLocalRing_quotient_span_singleton R x hx_mem
    let m := IsLocalRing.maximalIdeal R
    let m' := @IsLocalRing.maximalIdeal (R ⧸ I) _ h_local
    m →ₗ[R] m' :=
    let I := Ideal.span {x}
    let h_local := isLocalRing_quotient_span_singleton R x hx_mem
    let m := IsLocalRing.maximalIdeal R
    let m' := @IsLocalRing.maximalIdeal (R ⧸ I) _ h_local
    let f_fun := maximalIdealMapFun R x hx_mem
    {
      toFun := f_fun
      map_add' := fun a b => by
        -- By definition of $f_fun$, we have $f_fun (a + b) = (a + b) + I$ and $f_fun a + f_fun b = (a + I) + (b + I)$.
        simp [f_fun, maximalIdealMapFun]
      map_smul' := fun r a => by
        aesop
    }

/-
Checking if the maximal ideal of the quotient ring is an R-module.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R)
#synth Module R (@IsLocalRing.maximalIdeal (R ⧸ Ideal.span {x}) _ (isLocalRing_quotient_span_singleton R x hx_mem))

/-
Defining the square of the maximal ideal as a submodule of the maximal ideal.
-/
def m_sq_sub (R : Type*) [CommRing R] [IsLocalRing R] : Submodule R (IsLocalRing.maximalIdeal R) :=
  Submodule.comap (Submodule.subtype (IsLocalRing.maximalIdeal R)) (IsLocalRing.maximalIdeal R ^ 2)

/-
Defining the square of the maximal ideal of the quotient ring as a submodule of the maximal ideal.
-/
def m'_sq_sub (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    Submodule R (@IsLocalRing.maximalIdeal (R ⧸ Ideal.span {x}) _ (isLocalRing_quotient_span_singleton R x hx_mem)) :=
  let I := Ideal.span {x}
  let h_local := isLocalRing_quotient_span_singleton R x hx_mem
  let m' := @IsLocalRing.maximalIdeal (R ⧸ I) _ h_local
  (Submodule.restrictScalars R (m' ^ 2)).comap (m'.subtype.restrictScalars R)

/-
The image of the square of the maximal ideal under the map between maximal ideals is contained in the square of the maximal ideal of the quotient ring.
-/
lemma maximalIdealMap_image_sq_le_sq (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) :
    letI := isLocalRing_quotient_span_singleton R x hx_mem
    Submodule.map (maximalIdealMap R x hx_mem) (m_sq_sub R) ≤ m'_sq_sub R x hx_mem := by
      unfold m_sq_sub m'_sq_sub;
      rintro _ ⟨ y, hy, rfl ⟩;
      simp_all +decide [ Submodule.mem_comap, Submodule.mem_span_singleton ];
      -- By definition of $m_sq_sub$, we know that $y \in m^2$.
      have hy_sq : (y : R) ∈ IsLocalRing.maximalIdeal R ^ 2 := by
        exact hy;
      convert Ideal.mem_map_of_mem _ hy_sq using 1;
      rw [ Ideal.map_pow ];
      congr! 1;
      ext; simp [Ideal.mem_map_iff_of_surjective, Ideal.Quotient.mk_surjective];
      constructor;
      · intro h;
        obtain ⟨ z, rfl ⟩ := Ideal.Quotient.mk_surjective ‹_›;
        exact ⟨ z, by rintro H; exact h ( H.map ( Ideal.Quotient.mk ( Ideal.span { x } ) ) ), rfl ⟩;
      · rintro ⟨ z, hz, rfl ⟩ hunit;
        obtain ⟨ w, hw ⟩ := hunit.exists_left_inv;
        obtain ⟨ w, rfl ⟩ := Ideal.Quotient.mk_surjective w;
        erw [ Ideal.Quotient.eq ] at hw;
        rw [ Ideal.mem_span_singleton ] at hw;
        obtain ⟨ k, hk ⟩ := hw;
        replace hk := congr_arg ( fun y => Ideal.Quotient.mk ( IsLocalRing.maximalIdeal R ) y ) hk ; simp_all +decide [ Ideal.Quotient.eq_zero_iff_mem ];
        erw [ Ideal.Quotient.eq_zero_iff_mem.mpr ( show x ∈ IsLocalRing.maximalIdeal R from by exact? ) ] at hk ; simp_all +decide [ sub_eq_iff_eq_add ];
        exact absurd hk ( by erw [ Ideal.Quotient.eq_zero_iff_mem.mpr ( show z ∈ IsLocalRing.maximalIdeal R from by exact? ) ] ; simp +decide )
