/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d9c86a8e-b0e8-4506-826b-48c3583c3a3f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking for IsLocalRing.ResidueField and IsLocalRing.CotangentSpace.
-/
#check IsLocalRing.ResidueField
#check IsLocalRing.CotangentSpace

/-
Checking instances and types for the definition of regular local ring.
-/
variable (R : Type*) [CommRing R] [IsLocalRing R]
#synth Field (IsLocalRing.ResidueField R)
#synth Module (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)
#check (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) : WithBot ℕ∞)

/-
Definition of a regular local ring.
-/
/-- A regular local ring is a Noetherian local ring such that the Krull dimension is equal to the dimension of the cotangent space. -/
def IsRegularLocalRing (R : Type*) [CommRing R] [IsLocalRing R] : Prop :=
  IsNoetherianRing R ∧
  ringKrullDim R = (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) : WithBot ℕ∞)

/-
A regular local ring of dimension zero is a field.
-/
lemma regular_local_ring_dim_zero_is_field (R : Type*) [CommRing R] [IsLocalRing R] (h : IsRegularLocalRing R) (h_dim : ringKrullDim R = 0) : IsField R := by
  obtain ⟨ h1, h2 ⟩ := h; (
  have h_cotangent_space_zero : Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) = 0 := by
    aesop;
  exact?);

/-
If a regular local ring has positive dimension, there exists an element in the maximal ideal but not in its square.
-/
lemma exists_regular_param (R : Type*) [CommRing R] [IsLocalRing R] (h : IsRegularLocalRing R) (h_dim : ringKrullDim R > 0) :
    ∃ x ∈ IsLocalRing.maximalIdeal R, x ∉ IsLocalRing.maximalIdeal R ^ 2 := by
  -- Since $R$ is a regular local ring, its maximal ideal is finitely generated.
  have h_fg : (IsNoetherianRing R) := by
    exact h.1;
  by_contra! h_contra;
  -- If $M = M^2$, then by Nakayama's lemma, $M = 0$.
  have h_nakayama : IsLocalRing.maximalIdeal R = 0 := by
    apply Submodule.eq_bot_of_le_smul_of_le_jacobson_bot;
    exacts [ IsNoetherian.noetherian _, fun x hx => by simpa [ sq ] using h_contra x hx, by simp +decide [ IsLocalRing.jacobson_eq_maximalIdeal ] ];
  -- If $M = 0$, then $R$ is a field.
  have h_field : IsField R := by
    exact?;
  -- If $R$ is a field, then its Krull dimension is zero.
  have h_krull_zero : ringKrullDim R = 0 := by
    exact?;
  exact h_dim.ne' h_krull_zero

/-
The quotient of a local ring by a proper ideal is a local ring.
-/
instance isLocalRing_quotient_of_proper_ideal (R : Type*) [CommRing R] [IsLocalRing R] (I : Ideal R) (h : I ≠ ⊤) : IsLocalRing (R ⧸ I) := by
  refine' { .. };
  · refine' ⟨ 0, 1, _ ⟩;
    exact?;
  · rintro a b hab;
    obtain ⟨ x, rfl ⟩ := Ideal.Quotient.mk_surjective a; obtain ⟨ y, rfl ⟩ := Ideal.Quotient.mk_surjective b; simp_all +decide [ Ideal.Quotient.eq ] ;
    -- Since $x + y = 1$, we have $1 - x = y$. If $x$ is not a unit, then $1 - x$ must be a unit.
    have h_unit : ¬IsUnit x → IsUnit (1 - x) := by
      exact?;
    by_cases hx : IsUnit x <;> simp_all +decide [ ← eq_sub_iff_add_eq' ];
    · exact Or.inl ( IsUnit.map ( Ideal.Quotient.mk I ) hx );
    · exact Or.inr ( by simpa using h_unit.map ( Ideal.Quotient.mk I ) )

/-
The quotient of a local ring by the ideal generated by an element in the maximal ideal is a local ring.
-/
instance isLocalRing_quotient_span_singleton (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx : x ∈ IsLocalRing.maximalIdeal R) : IsLocalRing (R ⧸ Ideal.span {x}) := by
  have h_local_quotient : ∀ (I : Ideal R), I ≠ ⊤ → IsLocalRing (R ⧸ I) := by
    exact?;
  by_cases h : Ideal.span { x } = ⊤ <;> aesop

/-
If the quotient by an element is a domain, then the element is prime.
-/
lemma prime_of_quotient_domain (R : Type*) [CommRing R] (x : R) (h : IsDomain (R ⧸ Ideal.span {x})) (hx : x ≠ 0) : Prime x := by
  rw [ ← Ideal.span_singleton_prime hx ];
  exact?

/-
The dimension of the quotient of a finite-dimensional vector space by a non-zero vector drops by 1.
-/
lemma finrank_quotient_span_singleton {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] (v : V) (hv : v ≠ 0) :
    Module.finrank K (V ⧸ Submodule.span K {v}) + 1 = Module.finrank K V := by
  have := Submodule.finrank_quotient_add_finrank ( Submodule.span K { v } );
  rw [ ← this, finrank_span_singleton hv ]

/-
Definition of embedding dimension.
-/
/-- The embedding dimension of a local ring is the dimension of its cotangent space. -/
def embeddingDim (R : Type*) [CommRing R] [IsLocalRing R] : ℕ :=
  Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)

/-
Checking availability of definitions.
-/
#check embeddingDim
#check IsRegularLocalRing

/-
The image of an element in m \ m^2 is non-zero in the cotangent space.
-/
lemma to_cotangent_ne_zero (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) (hx_not_mem_sq : x ∉ IsLocalRing.maximalIdeal R ^ 2) :
    Ideal.toCotangent (IsLocalRing.maximalIdeal R) ⟨x, hx_mem⟩ ≠ 0 := by
  intro h;
  erw [ Submodule.Quotient.mk_eq_zero ] at h;
  simp_all +decide [ Submodule.mem_smul_top_iff ];
  exact hx_not_mem_sq ( by simpa only [ sq ] using h )

/-
The residue field of a quotient of a local ring is isomorphic to the residue field of the ring.
-/
def residueFieldQuotientIso (R : Type*) [CommRing R] [IsLocalRing R] (I : Ideal R) (hI : I ≠ ⊤) :
    @IsLocalRing.ResidueField (R ⧸ I) _ (isLocalRing_quotient_of_proper_ideal R I hI) ≃+* IsLocalRing.ResidueField R := by
  let R' := R ⧸ I
  haveI := isLocalRing_quotient_of_proper_ideal R I hI
  let m := IsLocalRing.maximalIdeal R
  let m' := IsLocalRing.maximalIdeal R'
  let f : R' →+* IsLocalRing.ResidueField R := Ideal.Quotient.lift I (Ideal.Quotient.mk m) (fun x hx => Ideal.Quotient.eq_zero_iff_mem.mpr (IsLocalRing.le_maximalIdeal hI hx))
  let g : IsLocalRing.ResidueField R' →+* IsLocalRing.ResidueField R := Ideal.Quotient.lift m' f (by
  simp +zetaDelta at *;
  intro a ha
  generalize_proofs at *;
  obtain ⟨ x, rfl ⟩ := Ideal.Quotient.mk_surjective a;
  contrapose! ha;
  -- Since $x \notin m$, $x$ is a unit in $R$.
  have hx_unit : IsUnit x := by
    exact?;
  exact hx_unit.map ( Ideal.Quotient.mk I ))
  apply RingEquiv.ofBijective g (by
  refine' ⟨ _, _ ⟩;
  · exact?;
  · intro x;
    obtain ⟨ y, hy ⟩ := Ideal.Quotient.mk_surjective x;
    exact ⟨ Ideal.Quotient.mk m' ( Ideal.Quotient.mk I y ), by aesop ⟩)

/-
Definition of the submodule generated by a regular parameter in the cotangent space.
-/
def regularParamSubmodule (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx : x ∈ IsLocalRing.maximalIdeal R) :
    Submodule (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R) :=
  Submodule.span (IsLocalRing.ResidueField R) {Ideal.toCotangent (IsLocalRing.maximalIdeal R) ⟨x, hx⟩}

/-
The dimension of the submodule generated by a regular parameter is 1.
-/
lemma finrank_regular_param_submodule_eq_one (R : Type*) [CommRing R] [IsLocalRing R] (x : R) (hx_mem : x ∈ IsLocalRing.maximalIdeal R) (hx_not_mem_sq : x ∉ IsLocalRing.maximalIdeal R ^ 2) :
    Module.finrank (IsLocalRing.ResidueField R) (regularParamSubmodule R x hx_mem) = 1 := by
  convert finrank_span_singleton _;
  exact?

/-
Checking if residueFieldQuotientIso is available.
-/
#check residueFieldQuotientIso