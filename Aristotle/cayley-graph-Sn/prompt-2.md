Goal: turn the conditional Lean development (based on `SnModel n`) into an unconditional theorem about the concrete Cayley graph of S_n generated by
  δ = (12), r = (12…n), r⁻¹ = (1n…2).

Input artifacts:
1) The Lean file (the one provided) defining:
   - `Sn_delta`, `Sn_r`, `Sn_s`, `Sn_generators`, `Sn_Gamma`, `Sn_dist`
   - `prefix_reversal`
   - `InversionCounter`, `SnModel`
   - theorems: `lemma_reversal`, `theorem_dist_sr`, `theorem_diam_lb`
2) Mathlib.

What must be proven to connect the paper’s Cayley graph to the Lean theorems:

A. “Model realization” theorem
Prove there exists an instance of `SnModel n` for the concrete definitions in the file:

  theorem exists_SnModel (n : ℕ) (h : 4 ≤ n) : ∃ model : SnModel n, True

Equivalently: explicitly define a `model : SnModel n` by specifying an inversion-like function `inv` and proving ALL fields of `SnModel n`.

B. Concrete content of the required `SnModel n` fields
You must supply:

B1. Define an inversion counter on `Equiv.Perm (Fin n)`:
  inv : Equiv.Perm (Fin n) → ℤ

This `inv` should correspond to the paper’s inversion count (or any other integer-valued statistic) that makes the axioms true.

B2. Prove the generator Lipschitz property for δ:
  delta_inv : ∀ p,
    inv (p * Sn_delta n) ≤ inv p + 1 ∧ inv (p * Sn_delta n) ≥ inv p - 1

Interpretation: right-multiplying by δ changes inv by at most 1.

B3. Prove invariance under rotation powers:
  r_inv : ∀ p (k : ℤ), inv (p * (Sn_r n ^ k)) = inv p

Interpretation: cyclic shifts do not change inv.

B4. Prove the “prefix reversal inversion gain” axiom:
  inv_gap :
    ∀ (j : ℕ) (p : Equiv.Perm (Fin n)),
      2 ≤ j → j ≤ (n + 1) / 2 →
      inv (p * prefix_reversal n j) - inv p = j * (j - 1) / 2

This is the key combinatorial lemma: reversing the first j entries produces exactly j(j−1)/2 more inversions relative to `inv`.

IMPORTANT: if your inversion notion differs from the paper’s, you must still prove exactly this equation.

B5. Prove finiteness of distances in the Cayley graph:
  dist_finite : ∀ x y, Sn_dist n x y ≠ ⊤

This should follow because Γ is a Cayley graph of a finitely generated finite group:
  - show the vertex type is finite
  - show Γ is connected (generators generate all of S_n)
  - use a Mathlib lemma: in a connected finite graph, dist is finite.

You will likely need a lemma that `Sn_generators n` generates `Equiv.Perm (Fin n)` as a subgroup.
(If your `Sn_generators` is missing a generator from the paper, fix the definitions or add the generator and re-run the chain.)

B6. Prove the word-metric lower bound from inv:
  dist_lower_bound :
    ∀ x y, ((Sn_dist n x y).toNat : ℤ) ≥ 2 * |inv y - inv x| - 1

This is a derived inequality that, in the paper, comes from:
  - each δ changes inv by ≤ 1
  - r and r⁻¹ preserve inv
  - thus any word of length L can change inv by ≤ ceil(L/2) (or a similar argument)
The Lean file demands exactly the inequality above. Prove it from B2/B3 plus a standard “path decomposes into generators” argument about `SimpleGraph.dist`.

If the constant “2*|…|-1” is not the tight inequality you can prove, you must either:
  (i) strengthen your argument to match it, or
  (ii) edit the Lean file’s axiom and re-prove downstream theorems (not preferred).

B7. Prove the Lee metric on the rotation orbit:
  lee_dist :
    ∀ (a b : ℕ), a < n → b < n →
      Sn_dist n (Sn_r n ^ a) (Sn_r n ^ b) = (min (Nat.dist a b) (n - Nat.dist a b) : ℕ)

This states that within the cyclic subgroup ⟨r⟩, the word metric induced by generators {δ, r, r⁻¹} restricts to the usual Lee distance using only r and r⁻¹ steps.
A standard proof:
  - show there is a path from r^a to r^b of length Nat.dist a b using r steps
  - also a path of length n - Nat.dist a b using r⁻¹ steps
  - show no shorter path exists because any word from r^a to r^b, after projecting to the quotient where δ becomes identity (or using an invariant), must use at least that many r/r⁻¹ moves.
(Any clean group/metric argument that yields exact equality is acceptable.)

C. Sanity checks / definitional alignment
Before proving B2–B7, confirm the definitions match the paper:

C1. `Sn_delta n` really is the transposition swapping 0 and 1 (i.e. (12) in 1-based notation) for n ≥ 2.
C2. `Sn_r n = finRotate n` corresponds to the n-cycle (12…n) in paper notation.
C3. `Sn_s n = Fin.revPerm` corresponds to the full reversal s = [n n−1 … 1].
C4. `Sn_generators n` matches the intended generating set. The paper uses {δ, r, r⁻¹}. Ensure the Lean set is exactly that.

If any mismatch is found, update the Lean definitions and re-check downstream theorems.

D. Final payoff theorem (already in file)
Once `model : SnModel n` is constructed for the concrete Cayley graph, you can instantiate:

  theorem concrete_diam_lb (n : ℕ) (h : 4 ≤ n) :
    ∃ x y : Equiv.Perm (Fin n), Sn_dist n x y ≥ ↑(n * (n - 1) / 2)

via `theorem_diam_lb n model h`.

Deliverable expected from the prover:
- A Lean file (or Lean code snippet) that defines `inv` and constructs `model : SnModel n` for all n ≥ 4.
- Minimal changes to the existing Lean file are preferred; ideally only additions (new definitions/lemmas/instance).

Notes:
- It is acceptable to introduce a new file `SnModelInstance.lean` that imports the provided file and constructs the instance.
- If proving B6 or B7 directly is difficult, you may replace them by stronger group-theoretic lemmas implying them, but you must end with exactly the required field types.
