/-
  Cayley Graph of Sₙ - Statements from generated-2.tex

  Cayley graph of Sₙ generated by δ = (12), r = (12⋯n), r⁻¹ = (1n⋯2)
-/

import Mathlib

open Equiv Equiv.Perm

variable (n : ℕ) [NeZero n]

/-! ## Basic Definitions -/

/-- The transposition (1 2) in Sₙ, swapping positions 0 and 1 -/
def delta : Perm (Fin n) :=
  if h : n ≥ 2 then swap ⟨0, Nat.zero_lt_of_lt h⟩ ⟨1, h⟩ else 1

/-- The n-cycle r = (1 2 ⋯ n) as a permutation: r(i) = i + 1 mod n -/
def cycleR : Perm (Fin n) where
  toFun i := ⟨(i.val + 1) % n, Nat.mod_lt _ (NeZero.pos n)⟩
  invFun i := ⟨(i.val + n - 1) % n, Nat.mod_lt _ (NeZero.pos n)⟩
  left_inv := by
    intro i
    refine Fin.ext ?_
    have hi := i.isLt
    have hn : 0 < n := NeZero.pos n
    -- goal: ((i.val + 1) % n + n - 1) % n = i.val
    by_cases h : i.val + 1 < n
    · -- i.val + 1 < n
      have hmod : (i.val + 1) % n = i.val + 1 := Nat.mod_eq_of_lt h
      simp only [hmod]
      have heq : i.val + 1 + n - 1 = i.val + n := by omega
      simp only [heq, Nat.add_mod_right, Nat.mod_eq_of_lt hi]
    · -- i.val + 1 ≥ n, so i.val = n - 1
      have heq : i.val = n - 1 := by omega
      simp only [heq]
      have hmod : (n - 1 + 1) % n = 0 := by
        rw [Nat.sub_add_cancel (Nat.one_le_of_lt hn), Nat.mod_self]
      simp only [hmod, Nat.zero_add, Nat.mod_eq_of_lt (by omega : n - 1 < n)]
  right_inv := by
    intro i
    refine Fin.ext ?_
    have hi := i.isLt
    have hn : 0 < n := NeZero.pos n
    -- goal: ((i.val + n - 1) % n + 1) % n = i.val
    by_cases h : i.val = 0
    · -- i.val = 0
      simp only [h, Nat.zero_add]
      have hmod : (n - 1) % n = n - 1 := Nat.mod_eq_of_lt (by omega : n - 1 < n)
      simp only [hmod]
      have heq : n - 1 + 1 = n := by omega
      simp only [heq, Nat.mod_self]
    · -- i.val > 0
      have hpos : 0 < i.val := Nat.pos_of_ne_zero h
      have hmod : (i.val + n - 1) % n = i.val - 1 := by
        have : i.val + n - 1 = i.val - 1 + n := by omega
        rw [this, Nat.add_mod_right, Nat.mod_eq_of_lt (by omega : i.val - 1 < n)]
      simp only [hmod]
      have heq : i.val - 1 + 1 = i.val := by omega
      simp only [heq, Nat.mod_eq_of_lt hi]

/-- The generating set {δ, r, r⁻¹} -/
def generators : Set (Perm (Fin n)) := {delta n, cycleR n, (cycleR n)⁻¹}

/-- Word length: minimal number of generators needed to express a permutation -/
noncomputable def wordLength (π : Perm (Fin n)) : ℕ :=
  sInf {L : ℕ | ∃ (w : List (Perm (Fin n))),
    (∀ g ∈ w, g ∈ generators n) ∧ w.length = L ∧ w.prod = π}

/-- Distance in the Cayley graph -/
noncomputable def cayleyDist (π ξ : Perm (Fin n)) : ℕ :=
  wordLength n (π⁻¹ * ξ)

/-- The reversal permutation s = [n, n-1, ..., 1] -/
def reversal : Perm (Fin n) where
  toFun i := ⟨n - 1 - i.val, by omega⟩
  invFun i := ⟨n - 1 - i.val, by omega⟩
  left_inv := by intro i; simp [Fin.ext_iff]; omega
  right_inv := by intro i; simp [Fin.ext_iff]; omega

/-! ## Lemma 1: Lee distance on ⟨r⟩ -/

/-- Lee distance: min(|t|, n - |t|) mod n -/
def leeDist (t : ℤ) : ℕ :=
  let t' := t % n
  min t'.natAbs (n - t'.natAbs)

/-- cycleR is in generators -/
lemma cycleR_mem_generators : cycleR n ∈ generators n := by
  unfold generators
  right; left; rfl

/-- cycleR⁻¹ is in generators -/
lemma cycleR_inv_mem_generators : (cycleR n)⁻¹ ∈ generators n := by
  unfold generators
  right; right; rfl

/-- cycleR has order n: r^n = 1.
    Proof: cycleR adds 1 mod n to each index, so n applications return to the original. -/
lemma cycleR_pow_n : (cycleR n) ^ n = 1 := by
  ext i
  simp only [Perm.coe_pow, Perm.coe_one, id_eq]
  -- cycleR^[n] i = i because adding n ≡ 0 (mod n)
  have hn : 0 < n := NeZero.pos n
  have key : ∀ k : ℕ, ((cycleR n)^[k] i).val = (i.val + k) % n := by
    intro k
    induction k with
    | zero =>
      simp only [Function.iterate_zero, id_eq]
      exact (Nat.mod_eq_of_lt i.isLt).symm
    | succ k ih =>
      simp only [Function.iterate_succ', Function.comp_apply]
      have hcycle : (cycleR n ((cycleR n)^[k] i)).val = (((cycleR n)^[k] i).val + 1) % n := by
        unfold cycleR
        rfl
      rw [hcycle, ih]
      have h1 : ((i.val + k) % n + 1) % n = (i.val + k + 1) % n := by
        rw [Nat.add_mod ((i.val + k) % n) 1 n]
        rw [Nat.mod_mod]
        rw [← Nat.add_mod]
      rw [h1]
      ring_nf
  have h := key n
  simp only [Nat.add_mod_right, Nat.mod_eq_of_lt i.isLt] at h
  exact h

/-- A list of k copies of r has product r^k -/
lemma replicate_cycleR_prod (k : ℕ) :
    (List.replicate k (cycleR n)).prod = (cycleR n) ^ k := by
  induction k with
  | zero => simp
  | succ k ih =>
    simp only [List.replicate_succ, List.prod_cons, ih]
    rw [pow_succ']

/-- Upper bound: wordLength is at most k for r^k -/
lemma wordLength_cycleR_pow_upper (k : ℕ) :
    wordLength n ((cycleR n) ^ k) ≤ k := by
  unfold wordLength
  apply Nat.sInf_le
  use List.replicate k (cycleR n)
  refine ⟨?_, ?_, ?_⟩
  · intro g hg
    simp only [List.mem_replicate, ne_eq] at hg
    obtain ⟨_, hg2⟩ := hg
    rw [hg2]
    exact cycleR_mem_generators n
  · simp
  · exact replicate_cycleR_prod n k

/-- r^k = (r⁻¹)^(n-k) when k ≤ n -/
lemma cycleR_pow_eq_inv_pow (k : ℕ) (hk : k ≤ n) :
    (cycleR n) ^ k = (cycleR n)⁻¹ ^ (n - k) := by
  have h1 : (cycleR n) ^ k * (cycleR n) ^ (n - k) = (cycleR n) ^ n := by
    rw [← pow_add]
    congr 1
    omega
  rw [cycleR_pow_n, mul_eq_one_iff_eq_inv] at h1
  rw [h1, inv_pow]

/-- Upper bound: wordLength is at most n - k for r^k when k ≤ n -/
lemma wordLength_cycleR_pow_upper' (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ n - k := by
  rw [cycleR_pow_eq_inv_pow n k hk]
  unfold wordLength
  apply Nat.sInf_le
  use List.replicate (n - k) (cycleR n)⁻¹
  refine ⟨?_, ?_, ?_⟩
  · intro g hg
    simp only [List.mem_replicate, ne_eq] at hg
    obtain ⟨_, hg2⟩ := hg
    rw [hg2]
    exact cycleR_inv_mem_generators n
  · simp
  · induction (n - k) with
    | zero => simp
    | succ m ih =>
      simp only [List.replicate_succ, List.prod_cons]
      rw [ih, pow_succ']

/-- The wordLength of r^k is bounded by min(k, n-k) when k ≤ n -/
lemma wordLength_cycleR_pow_le_min (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ min k (n - k) := by
  rw [le_min_iff]
  exact ⟨wordLength_cycleR_pow_upper n k, wordLength_cycleR_pow_upper' n k hk⟩

/-- Lee distance is symmetric: leeDist(-t) = leeDist(t) -/
lemma leeDist_neg (t : ℤ) : leeDist n (-t) = leeDist n t := by
  unfold leeDist
  -- The key insight: |(-t) mod n| and |t mod n| give the same Lee distance
  -- because min(k, n-k) = min(n-k, k)
  sorry

/-- The distance between powers of r is the Lee distance of their exponents.
    This follows from the fact that r and r⁻¹ are the only generators that
    stay within ⟨r⟩, and the shortest path uses min(k mod n, n - k mod n) steps.

    Proof sketch from the LaTeX document:
    - Right-multiplying by r increments the exponent by 1 mod n
    - Right-multiplying by r⁻¹ decrements the exponent by 1 mod n
    - The shortest path from r^a to r^b in the n-cycle is min(|a-b|, n-|a-b|) -/
theorem lee_distance (a b : ℤ) :
    cayleyDist n ((cycleR n) ^ a) ((cycleR n) ^ b) = leeDist n (a - b) := by
  unfold cayleyDist
  -- (r^a)⁻¹ * r^b = r^(-a) * r^b = r^(b-a)
  have h1 : ((cycleR n) ^ a)⁻¹ * (cycleR n) ^ b = (cycleR n) ^ (b - a) := by
    rw [← zpow_neg, ← zpow_add]
    ring_nf
  rw [h1]
  -- Now need: wordLength n (r^(b-a)) = leeDist n (a-b)
  -- Note: leeDist n (a-b) = leeDist n (b-a) by symmetry (min is symmetric)
  conv_rhs => rw [show a - b = -(b - a) by ring, leeDist_neg]
  -- Now show: wordLength n (r^(b-a)) = leeDist n (b-a)
  -- This requires showing both upper and lower bounds
  sorry

/-- Special case: distance from r^t to identity -/
theorem lee_distance_to_id (t : ℤ) :
    cayleyDist n ((cycleR n) ^ t) 1 = leeDist n t := by
  have h := lee_distance n t 0
  simp only [zpow_zero] at h
  convert h using 2
  ring

/-! ## Lemma 2: Swap-at-distance gadget -/

/-- The swap gadget W_d = (δr)^{d-1} δ (r⁻¹δ)^{d-1} -/
def swapGadget (d : ℕ) : Perm (Fin n) :=
  (delta n * cycleR n) ^ (d - 1) * delta n * ((cycleR n)⁻¹ * delta n) ^ (d - 1)

/-- The swap gadget has word length 4(d-1) + 1 for d ≥ 1 -/
theorem swapGadget_length (d : ℕ) (hd : d ≥ 1) :
    wordLength n (swapGadget n d) = 4 * (d - 1) + 1 := by
  sorry

/-- The swap gadget swaps elements at positions 0 and d -/
theorem swapGadget_effect (d : ℕ) (hd : 1 ≤ d) (hdn : d < n) (π : Perm (Fin n)) :
    ∃ (τ : Perm (Fin n)),
      (π * swapGadget n d) 0 = π ⟨d, hdn⟩ ∧
      (π * swapGadget n d) ⟨d, hdn⟩ = π 0 := by
  sorry

/-! ## Lemma 3: Arithmetic sum identity -/

/-- For j ≥ 2, m = ⌊j/2⌋: ∑_{k=1}^{m} (4(j-2k)+1) + (m-1) = j(j-1) - 1 -/
theorem arithmetic_sum (j : ℕ) (hj : j ≥ 2) :
    let m := j / 2
    (∑ k ∈ Finset.range m, (4 * (j - 2 * (k + 1)) + 1)) + (m - 1) = j * (j - 1) - 1 := by
  sorry

/-! ## Lemma 4: Reversal Lemma -/

/-- Prefix reversal: reverse the first j elements of a permutation -/
def prefixReversal (j : ℕ) (π : Perm (Fin n)) : Perm (Fin n) := by
  sorry -- The permutation ξ where ξ reverses positions 0..j-1 of π

/-- The reversal lemma: cost of a length-j prefix reversal (Formula I) -/
theorem reversal_cost_I (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n π (ξ * (cycleR n) ^ (j / 2 - 1 : ℤ)) = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula II) -/
theorem reversal_cost_II (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ (j - 2 : ℤ)) (ξ * (cycleR n) ^ ((j + 1) / 2 - 1 : ℤ))
      = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula III) -/
theorem reversal_cost_III (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ (j / 2 - 1 : ℤ)) ξ = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula IV) -/
theorem reversal_cost_IV (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ ((j + 1) / 2 - 1 : ℤ)) (ξ * (cycleR n) ^ (j - 2 : ℤ))
      = j * (j - 1) - 1 := by
  sorry

/-! ## Theorem 1: Distance from shifted reversal to identity -/

/-- The main distance formula for sr^{n-i} to identity -/
theorem main_distance_formula (hn : n ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ n) :
    cayleyDist n (reversal n * (cycleR n) ^ (n - i : ℤ)) 1 =
      ((n + 1) / 2) * ((n + 1) / 2 - 1) - 1 +
      (n / 2) * (n / 2 - 1) - 1 +
      (if i = 1 then n / 2 + 1
       else if i ≤ n / 2 + 2 then n / 2 - i + 4
       else i - (n + 1) / 2) := by
  sorry

/-! ## Theorem 2: Diameter lower bound -/

/-- The diameter of the Cayley graph -/
noncomputable def cayleyDiam : ℕ :=
  sSup {d : ℕ | ∃ π ξ : Perm (Fin n), cayleyDist n π ξ = d}

/-- Lower bound for the diameter: n(n-1)/2 -/
theorem diameter_lower_bound (hn : n ≥ 4) :
    cayleyDiam n ≥ n * (n - 1) / 2 := by
  sorry

/-- The specific witness: dist(sr^{n-2}, id) = n(n-1)/2 -/
theorem diameter_witness (hn : n ≥ 4) :
    cayleyDist n (reversal n * (cycleR n) ^ (n - 2 : ℤ)) 1 = n * (n - 1) / 2 := by
  sorry
