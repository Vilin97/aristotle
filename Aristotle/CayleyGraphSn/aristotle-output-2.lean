/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 390e5939-560c-4f3d-b851-5606333fabed

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check finRotate
#check Equiv.swap
#check SimpleGraph.diam

/-
The set of generators {(1 2), (1 2 ... n), (1 n ... 2)} for n >= 2.
-/
def generators (n : ℕ) : Set (Equiv.Perm (Fin n)) :=
  if h : 1 < n then
    {Equiv.swap ⟨0, by
      -- Since $n > 1$, we have $0 < n$.
      exact Nat.zero_lt_of_lt h⟩ ⟨1, by
      -- Since $n > 1$, we have $1 < n$.
      exact h⟩, finRotate n, (finRotate n)⁻¹}
  else
    ∅

/-
The Cayley graph of S_n with the generating set defined above.
-/
def cayleyGraph (n : ℕ) : SimpleGraph (Equiv.Perm (Fin n)) :=
  SimpleGraph.fromRel (fun g h => ∃ s ∈ generators n, h = g * s)

/-
Compute diameter for n=3 and n=4 using bounded BFS.
-/
def bfs_diameter_bounded (n : ℕ) (fuel : ℕ) : ℕ :=
  let generators : List (Equiv.Perm (Fin n)) :=
    if h : 1 < n then
      [Equiv.swap ⟨0, by exact Nat.zero_lt_of_lt h⟩ ⟨1, by exact h⟩, finRotate n, (finRotate n)⁻¹]
    else []
  let start := (1 : Equiv.Perm (Fin n))
  let rec loop (queue : List (Equiv.Perm (Fin n) × ℕ)) (visited : List (Equiv.Perm (Fin n))) (max_d : ℕ) (fuel : ℕ) : ℕ :=
    match fuel with
    | 0 => max_d
    | fuel + 1 =>
      match queue with
      | [] => max_d
      | (u, d) :: rest =>
        if u ∈ visited then
          loop rest visited max_d (fuel + 1) -- Don't consume fuel for visited check? Or do? Let's consume to be safe/simple.
          -- Actually, if we consume fuel for visited, we might run out.
          -- But for small n, it's fine.
        else
          let neighbors := generators.map (fun g => u * g)
          let new_queue := rest ++ neighbors.map (fun v => (v, d + 1))
          loop new_queue (u :: visited) (max d max_d) fuel
  loop [(start, 0)] [] 0 fuel

#eval bfs_diameter_bounded 3 1000
#eval bfs_diameter_bounded 4 100000

/-
Compute diameter for n=5 using bounded BFS.
-/
#eval bfs_diameter_bounded 5 1000000

/-
Compute distance to target permutation for n=3 and n=4.
-/
def target_perm (n : ℕ) : Equiv.Perm (Fin n) :=
  if h : 1 < n then
    let s := Equiv.swap (⟨0, by exact Nat.zero_lt_of_lt h⟩ : Fin n) ⟨1, by exact h⟩
    let r := finRotate n
    s * (r ^ (n - 2))
  else
    1

def bfs_dist_to_target (n : ℕ) (target : Equiv.Perm (Fin n)) (fuel : ℕ) : Option ℕ :=
  let generators : List (Equiv.Perm (Fin n)) :=
    if h : 1 < n then
      [Equiv.swap ⟨0, by exact Nat.zero_lt_of_lt h⟩ ⟨1, by exact h⟩, finRotate n, (finRotate n)⁻¹]
    else []
  let start := (1 : Equiv.Perm (Fin n))
  let rec loop (queue : List (Equiv.Perm (Fin n) × ℕ)) (visited : List (Equiv.Perm (Fin n))) (fuel : ℕ) : Option ℕ :=
    match fuel with
    | 0 => none
    | fuel + 1 =>
      match queue with
      | [] => none
      | (u, d) :: rest =>
        if u = target then some d
        else if u ∈ visited then
          loop rest visited fuel
        else
          let neighbors := generators.map (fun g => u * g)
          let new_queue := rest ++ neighbors.map (fun v => (v, d + 1))
          loop new_queue (u :: visited) fuel
  loop [(start, 0)] [] fuel

#eval bfs_dist_to_target 3 (target_perm 3) 1000
#eval bfs_dist_to_target 4 (target_perm 4) 100000

/-
Check distance to target for n=5.
-/
#eval bfs_dist_to_target 5 (target_perm 5) 1000000

/-
Find permutations at maximum distance for n=4.
-/
def find_farthest_nodes (n : ℕ) : List (Equiv.Perm (Fin n) × ℕ) :=
  let generators : List (Equiv.Perm (Fin n)) :=
    if h : 1 < n then
      [Equiv.swap ⟨0, by exact Nat.zero_lt_of_lt h⟩ ⟨1, by exact h⟩, finRotate n, (finRotate n)⁻¹]
    else []
  let start := (1 : Equiv.Perm (Fin n))
  let rec loop (queue : List (Equiv.Perm (Fin n) × ℕ)) (visited : List (Equiv.Perm (Fin n))) (max_d : ℕ) (farthest : List (Equiv.Perm (Fin n) × ℕ)) (fuel : ℕ) : List (Equiv.Perm (Fin n) × ℕ) :=
    match fuel with
    | 0 => farthest
    | fuel + 1 =>
      match queue with
      | [] => farthest
      | (u, d) :: rest =>
        if u ∈ visited then
          loop rest visited max_d farthest fuel
        else
          let new_farthest := if d > max_d then [(u, d)] else if d == max_d then (u, d) :: farthest else farthest
          let new_max_d := if d > max_d then d else max_d
          let neighbors := generators.map (fun g => u * g)
          let new_queue := rest ++ neighbors.map (fun v => (v, d + 1))
          loop new_queue (u :: visited) new_max_d new_farthest fuel
  loop [(start, 0)] [] 0 [] 100000

#eval find_farthest_nodes 4

/-
Arithmetic sum identity: for j >= 2 and m = floor(j/2), sum_{k=1}^m (4(j-2k)+1) + (m-1) = j(j-1)-1.
-/
theorem lemma_sum (j : ℕ) (h : 2 ≤ j) :
    let m := j / 2
    (∑ k ∈ Finset.range m, (4 * (j - 2 * (k + 1)) + 1)) + (m - 1) = j * (j - 1) - 1 := by
  -- We'll use the fact that $m = \lfloor j/2 \rfloor$ to split the sum into two cases: when $j$ is even and when $j$ is odd.
  by_cases h_even : Even j;
  · obtain ⟨ k, rfl ⟩ := h_even;
    simp +arith +decide [ Nat.add_div ];
    rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.mul_succ ];
    induction k <;> simp +arith +decide [ Finset.sum_range_succ', Nat.mul_succ ] at * ; linarith;
  · rcases Nat.even_or_odd' j with ⟨ k, rfl | rfl ⟩ <;> simp_all +arith +decide [ Nat.mul_succ ];
    norm_num [ Nat.add_div ];
    rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Finset.sum_add_distrib, mul_add ];
    induction k <;> simp_all +arith +decide [ Finset.sum_range_succ', Nat.mul_succ ];
    linarith

/-
The permutation that reverses the prefix of length j (if j <= n, else identity).
-/
def reversePrefix (n j : ℕ) : Equiv.Perm (Fin n) :=
  if h : j ≤ n then
    Equiv.mk (fun i => if (i : ℕ) < j then ⟨j - 1 - (i : ℕ), by
      omega⟩ else i)
      (fun i => if (i : ℕ) < j then ⟨j - 1 - (i : ℕ), by
        omega⟩ else i)
      (by
      -- To prove the left inverse, we need to show that applying the function twice returns the original element.
      intro i
      simp [Function.LeftInverse]
      generalize_proofs at *;
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      exact Fin.ext ( by norm_num; omega ))
      (by
      -- To prove the right inverse, we need to show that applying Rj twice gives the identity permutation.
      intros i; simp [Function.RightInverse];
      split_ifs <;> simp_all +decide [ Fin.ext_iff ];
      · omega;
      · omega)
  else
    1

/-
The target permutation s r^{n-2} where s is the full reversal.
-/
def target_reversal (n : ℕ) : Equiv.Perm (Fin n) :=
  reversePrefix n n * (finRotate n)^(n-2)

/-
The length of the gadget W_d is 4(d-1)+1.
-/
def gadget (n d : ℕ) (h : 1 < n) : List (Equiv.Perm (Fin n)) :=
  let delta := Equiv.swap (⟨0, by exact Nat.zero_lt_of_lt h⟩ : Fin n) ⟨1, by exact h⟩
  let r := finRotate n
  let r_inv := (finRotate n)⁻¹
  let seq1 := (List.replicate (d - 1) [delta, r]).flatten
  let seq2 := [delta]
  let seq3 := (List.replicate (d - 1) [r_inv, delta]).flatten
  seq1 ++ seq2 ++ seq3

theorem gadget_length (n d : ℕ) (h : 1 < n) (hd : 1 ≤ d) :
    (gadget n d h).length = 4 * (d - 1) + 1 := by
  unfold gadget;
  simp +arith +decide

/-
Properties of the gadget permutation: base case and recurrence.
-/
def gadget_perm (n d : ℕ) (h : 1 < n) : Equiv.Perm (Fin n) :=
  (gadget n d h).prod

theorem gadget_perm_one (n : ℕ) (h : 1 < n) :
    gadget_perm n 1 h = Equiv.swap ⟨0, by
      grind⟩ ⟨1, by
      grind⟩ := by
      bound

theorem gadget_perm_succ (n d : ℕ) (h : 1 < n) (hd : 1 ≤ d) :
    gadget_perm n (d + 1) h =
      let delta := Equiv.swap (⟨0, by
        linarith⟩ : Fin n) ⟨1, by
        -- Since $1 < n$ is given by the hypothesis $h$, we can directly use it to conclude the goal.
        exact h⟩
      let r := finRotate n
      delta * r * gadget_perm n d h * r⁻¹ * delta := by
        unfold gadget_perm;
        unfold gadget;
        cases d <;> simp_all +decide [ List.replicate ];
        ext ; simp +decide [ mul_assoc ];
        congr! 1;
        induction ‹ℕ› <;> simp_all +decide [ pow_succ', mul_assoc ]

/-
The gadget W_d corresponds to the transposition (0 d).
-/
theorem gadget_effect (n d : ℕ) (h : 1 < n) (hd : 1 ≤ d) (hdn : d < n) :
    gadget_perm n d h = Equiv.swap (⟨0, by exact Nat.zero_lt_of_lt h⟩ : Fin n) ⟨d, by exact hdn⟩ := by
  -- We proceed by induction on $d$.
  induction' d with d ih;
  · contradiction;
  · rcases d with ( _ | d ) <;> simp_all +decide [ gadget_perm_succ ];
    · exact?;
    · -- By definition of `finRotate`, we know that `finRotate n * (0 d+1) * (finRotate n)⁻¹` is the cycle `(1 d+2)`.
      have h_cycle : finRotate n * Equiv.swap ⟨0, by linarith⟩ ⟨d + 1, by linarith⟩ * (finRotate n)⁻¹ = Equiv.swap ⟨1, by linarith⟩ ⟨d + 2, by linarith⟩ := by
        ext i; simp +decide [ Equiv.swap_apply_def ];
        split_ifs <;> simp_all +decide [ finRotate ];
        all_goals rcases n with ( _ | _ | n ) <;> norm_num [ Fin.ext_iff, Equiv.Perm.inv_eq_iff_eq ] at *;
        all_goals norm_num [ finAddFlip ] at *;
        all_goals norm_num [ finSumFinEquiv ] at *;
        all_goals norm_num [ Fin.addCases ] at *;
        all_goals split_ifs at * <;> norm_num at *;
        all_goals omega;
      simp_all +decide [ mul_assoc ];
      simp_all +decide [ ← mul_assoc, ih ( by linarith ) ];
      ext x ; simp +decide [ Equiv.swap_apply_def ] ; aesop

/-
Helper definition for the product of swaps.
-/
def swap_k (n j k : ℕ) : Equiv.Perm (Fin n) :=
  if h : k < n ∧ j - 1 - k < n then
    Equiv.swap ⟨k, h.1⟩ ⟨j - 1 - k, h.2⟩
  else
    1

def reversal_swaps_prod (n j : ℕ) : Equiv.Perm (Fin n) :=
  let m := j / 2
  (List.range m).map (fun k => swap_k n j k) |>.prod

/-
The permutation obtained by applying the sequence of gadgets and shifts.
-/
def reversal_gadgets_perm (n j : ℕ) (h : 1 < n) : Equiv.Perm (Fin n) :=
  let m := j / 2
  let r := finRotate n
  (List.range m).map (fun k =>
    let d := j - 1 - 2 * k
    let w := gadget_perm n d h
    if k < m - 1 then w * r else w
  ) |>.prod

/-
The product of disjoint swaps (k, j-1-k) is the prefix reversal permutation.
-/
theorem reversal_swaps_eq_reversePrefix (n j : ℕ) (hj : j ≤ n) :
    reversal_swaps_prod n j = reversePrefix n j := by
  -- By definition of `reversePrefix`, it is the product of the swaps (k, j-1-k) for k in the range m.
  have h_reversePrefix : reversePrefix n j = List.prod (List.map (fun k => swap_k n j k) (List.range (j / 2))) := by
    ext i;
    by_cases hi : i.val < j <;> simp +decide [ *, reversePrefix ];
    · -- By definition of `swap_k`, the product of the swaps reverses the first `j` elements.
      have h_swap_product : ∀ (k : ℕ), k ≤ j / 2 → (List.prod (List.map (fun k => swap_k n j k) (List.range k))) i = if i.val < j then if i.val < k then ⟨j - 1 - i.val, by omega⟩ else if i.val ≥ j - k then ⟨j - 1 - i.val, by omega⟩ else i else i := by
        intro k hk;
        induction' k with k ih generalizing i <;> simp_all +decide [ List.range_succ ];
        split_ifs <;> simp_all +decide [ Nat.lt_succ_iff ];
        · rw [ ih ];
          all_goals norm_num [ swap_k ];
          any_goals omega;
          all_goals split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ];
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
            omega;
          · grind;
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
            · omega;
            · omega;
          · grind;
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
            · exact?;
            · omega;
        · rw [ ih ] <;> norm_num [ swap_k ];
          any_goals omega;
          all_goals split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ];
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
          · grind;
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
            · omega;
            · omega;
          · exact absurd ( ‹k < n → n ≤ j - 1 - k› ( by linarith ) ) ( by omega );
          · grind;
        · rw [ ih ];
          all_goals norm_num [ swap_k ];
          any_goals omega;
          all_goals split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ];
          any_goals omega;
          grind;
          grind;
          · grind;
          · split_ifs <;> simp_all +decide [ Fin.ext_iff ];
            omega;
      grind;
    · -- Since $i \geq j$, the product of the swaps does not affect $i$, so the result is $i$ itself.
      have h_swap_ge_j : ∀ (l : List (Equiv.Perm (Fin n))), (∀ g ∈ l, ∀ i : Fin n, i.val ≥ j → g i = i) → ∀ i : Fin n, i.val ≥ j → (List.prod l) i = i := by
        intro l hl i hi; induction l <;> aesop;
      specialize h_swap_ge_j (List.map (fun k => swap_k n j k) (List.range (j / 2)));
      simp_all +decide [ swap_k ];
      rw [ h_swap_ge_j ];
      · intro a ha i hi; split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ] ;
        grind;
      · linarith;
  exact h_reversePrefix.symm

/-
The effect of the reversal swaps product on an element i.
-/
theorem reversal_swaps_apply (n j : ℕ) (i : Fin n) (hj : j ≤ n) :
    reversal_swaps_prod n j i = if (i : ℕ) < j then ⟨j - 1 - (i : ℕ), by omega⟩ else i := by
  convert congr_arg ( fun f : Equiv.Perm ( Fin n ) => f i ) ( reversal_swaps_eq_reversePrefix n j hj ) using 1
  generalize_proofs at *;
  unfold reversePrefix; aesop;

/-
Conjugating the swap (0, d) by r^k yields the swap (k, k+d).
-/
theorem conjugate_swap_shift (n k d : ℕ) (h : 1 < n) (hk : k < n) (hd : d < n) (hkd : k + d < n) :
    (finRotate n)^k * Equiv.swap (⟨0, by exact Nat.zero_lt_of_lt h⟩ : Fin n) ⟨d, by exact hd⟩ * ((finRotate n)^k)⁻¹ =
    Equiv.swap ⟨k, by exact hk⟩ ⟨k + d, by exact hkd⟩ := by
  ext x; simp +decide [ Equiv.swap_apply_def, Equiv.Perm.mul_apply ] ; (
  -- By definition of `finRotate`, we know that `(finRotate n ^ k) x = x + k` and `(finRotate n ^ k)⁻¹ x = x - k`.
  have h_rotate : ∀ x : Fin n, (finRotate n ^ k) x = ⟨(x + k) % n, Nat.mod_lt _ (by linarith)⟩ ∧ (finRotate n ^ k)⁻¹ x = ⟨(x + n - k) % n, Nat.mod_lt _ (by linarith)⟩ := by
    have h_rotate : ∀ x : Fin n, (finRotate n ^ k) x = ⟨(x + k) % n, Nat.mod_lt _ (by linarith)⟩ := by
      induction' k with k ih;
      · norm_num [ Fin.ext_iff, Nat.mod_eq_of_lt ];
      · induction' k + 1 with k ih <;> simp_all +decide [ pow_succ', Function.comp ];
        · exact fun x => Eq.symm ( Fin.ext <| Nat.mod_eq_of_lt x.2 );
        · rcases n with ( _ | _ | n ) <;> simp_all +decide [ Fin.add_def, Nat.mod_eq_of_lt ];
          exact fun x => by ring;
    have h_rotate_inv : ∀ x : Fin n, (finRotate n ^ k)⁻¹ x = ⟨(x + n - k) % n, Nat.mod_lt _ (by linarith)⟩ := by
      intro x
      have h_inv : (finRotate n ^ k) (⟨(x + n - k) % n, Nat.mod_lt _ (by linarith)⟩) = x := by
        simp +decide [ h_rotate, Nat.mod_eq_of_lt ];
        exact Fin.ext ( by simp +decide [ Nat.sub_add_cancel ( show k ≤ x + n from by linarith [ Fin.is_lt x ] ), Nat.mod_eq_of_lt ] )
      exact?;
    exact fun x => ⟨ h_rotate x, h_rotate_inv x ⟩;
  split_ifs <;> simp_all +decide [ Fin.ext_iff, Nat.mod_eq_of_lt ];
  · rw [ add_comm, Nat.mod_eq_of_lt ] ; linarith;
  · simp_all +decide [ add_assoc, Nat.add_sub_assoc ];
    rw [ Nat.mod_eq_of_lt ] at * <;> omega;
  · have := Nat.dvd_of_mod_eq_zero ‹_›; obtain ⟨ y, hy ⟩ := this; simp_all +decide [ Nat.add_sub_assoc hk.le ] ;
    rcases y with ( _ | _ | y ) <;> simp_all! +arith +decide [ Nat.mod_eq_of_lt ];
    · omega;
    · omega;
    · nlinarith [ Nat.sub_add_cancel hk.le, Fin.is_lt x ];
  · have := Nat.mod_add_div ( x + n - k ) n; simp_all +decide [ Nat.mod_eq_of_lt ] ;
    rcases u : ( ( x + n - k ) / n ) with ( _ | _ | u ) <;> simp_all +decide [ Nat.mul_succ ] ; omega;
    · omega;
    · omega;
  · simp_all +decide [ add_assoc, Nat.add_sub_of_le ( by linarith : k ≤ k + d + n ) ];
    exact ‹¬d % n = d› ( Nat.mod_eq_of_lt hd ))

/-
The total length of the gadget sequence is j(j-1)-1.
-/
def reversal_gadgets_length (n j : ℕ) : ℕ :=
  let m := j / 2
  (List.range m).map (fun k =>
    let d := j - 1 - 2 * k
    let len_w := 4 * (d - 1) + 1
    if k < m - 1 then len_w + 1 else len_w
  ) |>.sum

theorem reversal_gadgets_length_eq (n j : ℕ) (h : 2 ≤ j) :
    reversal_gadgets_length n j = j * (j - 1) - 1 := by
  unfold reversal_gadgets_length;
  -- We can split the sum into two parts: the sum for k < m-1 and the sum for k = m-1.
  have h_split_sum : (List.map (fun k => if k < j / 2 - 1 then 4 * (j - 2 - 2 * k) + 2 else 4 * (j - 2 - 2 * k) + 1) (List.range (j / 2))).sum = (∑ k ∈ Finset.range (j / 2 - 1), (4 * (j - 2 - 2 * k) + 2)) + (4 * (j - 2 - 2 * (j / 2 - 1)) + 1) := by
    rcases k : j / 2 with ( _ | k ) <;> simp_all +arith +decide [ Finset.sum_range_succ ];
    · linarith;
    · simp +arith +decide [ Finset.sum_range_succ, List.range_succ ];
      rw [ add_assoc, ← Finset.sum_congr rfl ] ; aesop;
      exact fun x hx => if_pos <| Finset.mem_range.mp hx;
  rcases Nat.even_or_odd' j with ⟨ c, rfl | rfl ⟩ <;> simp_all +arith +decide [ Nat.mul_succ, Finset.sum_add_distrib ];
  · convert h_split_sum using 1;
    · grind;
    · rcases c with ( _ | _ | c ) <;> simp +arith +decide [ Nat.mul_succ, Finset.sum_add_distrib ] at *;
      exact Nat.recOn c ( by norm_num ) fun n ih => by simp +decide [ Nat.mul_succ, Finset.sum_range_succ' ] at * ; linarith;
  · norm_num [ Nat.add_div ] at *;
    rcases c with ( _ | _ | c ) <;> simp_all +decide [ Nat.sub_sub, Nat.mul_succ, Finset.sum_add_distrib ];
    exact Nat.recOn c ( by norm_num ) fun n ih => by simp +decide [ Nat.mul_succ, Finset.sum_range_succ' ] at * ; linarith;

/-
The gadget product equals the prefix reversal times a shift.
-/
theorem reversal_gadgets_eq_target (n j : ℕ) (h : 1 < n) (hj : j ≤ n) :
    reversal_gadgets_perm n j h = reversal_swaps_prod n j * (finRotate n)^(j / 2 - 1) := by
  -- By definition of $swap_k$, we know that $swap_k n j k = (finRotate n)^k * gadget_perm n (j - 1 - 2 * k) h * ((finRotate n)^k)⁻¹$.
  have h_swap_k : ∀ k < j / 2, swap_k n j k = (finRotate n)^k * gadget_perm n (j - 1 - 2 * k) h * ((finRotate n)^k)⁻¹ := by
    intro k hk
    have h_swap_k_def : swap_k n j k = Equiv.swap (⟨k, by
      omega⟩ : Fin n) ⟨k + (j - 1 - 2 * k), by
      omega⟩ := by
      unfold swap_k;
      grind
    generalize_proofs at *;
    rw [ h_swap_k_def ];
    have h_conj : (finRotate n)^k * Equiv.swap (⟨0, by
      grind⟩ : Fin n) ⟨j - 1 - 2 * k, by
      omega⟩ * ((finRotate n)^k)⁻¹ = Equiv.swap (⟨k, by
      grind⟩ : Fin n) ⟨k + (j - 1 - 2 * k), by
      assumption⟩ := by
      convert conjugate_swap_shift n k ( j - 1 - 2 * k ) h ( by linarith ) ( by linarith ) ( by linarith ) using 1
    generalize_proofs at *;
    rw [ ← h_conj, gadget_effect ];
    · omega;
    · assumption;
  -- By induction on the length of the list, we can show that the product of the gadgets is equal to the product of the swaps times the shift.
  have h_ind : ∀ m : ℕ, (∀ k < m, swap_k n j k = (finRotate n)^k * gadget_perm n (j - 1 - 2 * k) h * ((finRotate n)^k)⁻¹) → (List.prod (List.map (fun k => if k < m - 1 then gadget_perm n (j - 1 - 2 * k) h * finRotate n else gadget_perm n (j - 1 - 2 * k) h) (List.range m))) = (List.prod (List.map (fun k => swap_k n j k) (List.range m))) * (finRotate n)^(m - 1) := by
    intros m hm; induction' m with m ih <;> simp_all +decide [ List.range_succ ] ;
    induction' m with m ih <;> simp_all +decide [ List.range_succ ];
    simp_all +decide [ ← mul_assoc, pow_succ' ];
    rw [ show ( List.map ( fun k => if k < m + 1 then gadget_perm n ( j - 1 - 2 * k ) h * finRotate n else gadget_perm n ( j - 1 - 2 * k ) h ) ( List.range m ) ) = List.map ( fun k => if k < m then gadget_perm n ( j - 1 - 2 * k ) h * finRotate n else gadget_perm n ( j - 1 - 2 * k ) h ) ( List.range m ) from ?_ ];
    · rw [ ih fun k hk => hm k ( by linarith ) ] ; simp +decide [ hm m ( by linarith ), mul_assoc ];
      group;
    · norm_num +zetaDelta at *;
      exact fun k hk => by rw [ if_pos ( by linarith ), if_pos hk ] ;
  exact h_ind _ h_swap_k

/-
Check distance to target for n=4.
-/
#eval bfs_dist_to_target 4 (target_reversal 4) 100000

/-
The generators generate the full symmetric group.
-/
theorem generators_generate_Sn (n : ℕ) (h : 2 ≤ n) :
    Subgroup.closure (generators n) = ⊤ := by
      rw [ Subgroup.eq_top_iff' ];
      -- By definition of generators, the subgroup generated by the generators contains all transpositions.
      have h_transpositions : ∀ i j : Fin n, i ≠ j → Equiv.swap i j ∈ Subgroup.closure (generators n) := by
        -- By definition of generators, the subgroup generated by the generators contains all transpositions (i, i+1).
        have h_transpositions : ∀ i : Fin (n - 1), Equiv.swap ⟨i.val, by
          exact lt_of_lt_of_le i.2 ( Nat.pred_le _ )⟩ ⟨i.val + 1, by
          exact Nat.succ_lt_of_lt_pred i.2⟩ ∈ Subgroup.closure (generators n) := by
          intro i
          generalize_proofs at *;
          -- By definition of generators, the subgroup generated by the generators contains all transpositions (i, i+1) for i < n-1.
          have h_transpositions : ∀ i : Fin (n - 1), Equiv.swap ⟨0, by
            linarith⟩ ⟨1, by
            linarith⟩ ∈ Subgroup.closure (generators n) ∧ (finRotate n)^i.val * Equiv.swap ⟨0, by
            linarith⟩ ⟨1, by
            linarith⟩ * ((finRotate n)^i.val)⁻¹ ∈ Subgroup.closure (generators n) := by
            intro i
            generalize_proofs at *;
            unfold generators; aesop;
          generalize_proofs at *;
          convert h_transpositions i |>.2 using 1;
          exact?
        generalize_proofs at *;
        intro i j hij;
        -- By induction on $j - i$, we can show that any transposition $(i, j)$ can be written as a product of adjacent transpositions.
        have h_induction : ∀ i j : Fin n, i < j → Equiv.swap i j ∈ Subgroup.closure (generators n) := by
          intros i j hij
          induction' j with j hj generalizing i;
          induction' j with j hj generalizing i;
          · tauto;
          · rcases eq_or_lt_of_le ( show i ≤ ⟨ j, by linarith ⟩ from Nat.le_of_lt_succ hij ) with rfl | hi <;> simp_all +decide [ Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ];
            · convert h_transpositions ⟨ j, Nat.lt_pred_iff.mpr ‹_› ⟩ using 1;
            · have := hj ( by linarith ) i hi;
              have := h_transpositions ⟨ j, Nat.lt_pred_iff.mpr ‹_› ⟩;
              convert Subgroup.mul_mem _ ( Subgroup.mul_mem _ ‹Equiv.swap i ⟨ j, by linarith ⟩ ∈ Subgroup.closure ( generators n ) › this ) ‹Equiv.swap i ⟨ j, by linarith ⟩ ∈ Subgroup.closure ( generators n ) › using 1 ; simp +decide [ Equiv.swap_comm ];
              ext x; simp +decide [ Equiv.swap_apply_def ] ; aesop;
        cases lt_or_gt_of_ne hij <;> [ exact h_induction _ _ ‹_› ; exact Subgroup.inv_mem _ ( h_induction _ _ ‹_› ) |> fun h => by simpa [ Equiv.swap_comm ] using h ];
      intro x
      induction' x using Equiv.Perm.swap_induction_on with i j hij x ih;
      · exact OneMemClass.one_mem _;
      · exact Subgroup.mul_mem _ ( h_transpositions _ _ x ) ih

/-
The length of the two-block construction equals n(n-1)/2.
-/
def two_block_length (n : ℕ) : ℕ :=
  let a := n / 2
  let b := (n + 1) / 2
  (a * (a - 1) - 1) + (b * (b - 1) - 1) + (a + 2)

theorem two_block_length_eq (n : ℕ) (h : 4 ≤ n) :
    two_block_length n = n * (n - 1) / 2 := by
  unfold two_block_length;
  rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num;
  · rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.mul_succ ] at *;
    norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring;
    linarith [ Nat.div_mul_cancel ( show 2 ∣ k * 6 from ⟨ k * 3, by ring ⟩ ), Nat.sub_add_cancel ( show 1 ≤ 2 + k * 3 + k ^ 2 from by nlinarith ) ];
  · norm_num [ Nat.add_div ];
    exact Eq.symm ( Nat.div_eq_of_eq_mul_left zero_lt_two ( by nlinarith [ Nat.sub_add_cancel ( show 1 ≤ k from by linarith ), Nat.sub_add_cancel ( show 1 ≤ ( k + 1 ) * k from by nlinarith ), Nat.sub_add_cancel ( show 1 ≤ k * ( k - 1 ) from Nat.mul_pos ( by linarith ) ( Nat.sub_pos_of_lt ( by linarith ) ) ) ] ) )

#check Equiv.Perm.closure_cycle_adjacent_swap
#check finRotate
#check isCycle_finRotate_of_le
#check support_finRotate_of_le

/-
The generators generate the full symmetric group.
-/
theorem generators_generate_Sn_proof (n : ℕ) (h : 2 ≤ n) :
    Subgroup.closure (generators n) = ⊤ := by
      exact?

/-
finRotate n 0 = 1 for n >= 2.
-/
theorem finRotate_zero_val (n : ℕ) (h : 2 ≤ n) :
    finRotate n ⟨0, by
      linarith⟩ = ⟨1, by
      grind⟩ := by
      cases n <;> aesop
      skip

/-
finRotate n 0 = 1 for n >= 2.
-/
theorem finRotate_zero_lemma {n : ℕ} (h : 2 ≤ n) :
    finRotate n ⟨0, by
      linarith⟩ = ⟨1, by
      -- Since $2 \leq n$, we have $1 < n$.
      exact Nat.lt_of_succ_le h⟩ := by
      exact?

/-
The generators include the rotation and the swap (0 1).
-/
theorem rotate_mem_generators (n : ℕ) (h : 2 ≤ n) :
    finRotate n ∈ generators n := by
      unfold generators; aesop;

theorem swap_mem_generators (n : ℕ) (h : 2 ≤ n) :
    Equiv.swap (⟨0, by
      linarith⟩ : Fin n) ⟨1, by
      grind⟩ ∈ generators n := by
      unfold generators; aesop;

#check finRotate_succ_apply

/-
finRotate n 0 = 1 for n >= 2.
-/
theorem finRotate_zero_final (n : ℕ) (h : 2 ≤ n) :
    finRotate n ⟨0, by
      grind⟩ = ⟨1, by
      linarith⟩ := by
      exact?

/-
finRotate n 0 = 1 for n >= 2.
-/
theorem finRotate_zero_final_v2 (n : ℕ) (h : 2 ≤ n) :
    finRotate n ⟨0, by
      -- Since $2 \leq n$, we have $0 < n$.
      exact Nat.zero_lt_of_lt h⟩ = ⟨1, by
      -- Since $2 \leq n$, we have $1 < n$.
      exact lt_of_lt_of_le (by norm_num) h⟩ := by
      -- By definition of `finRotate`, we know that `finRotate n 0 = 1` for `n >= 2`, so we can conclude the proof.
      apply finRotate_zero_val n h

/-
The Cayley graph is connected because the generators generate the group.
-/
theorem cayleyGraph_connected (n : ℕ) (h : 2 ≤ n) :
    (cayleyGraph n).Connected := by
  -- We know the generators generate the group
  have h_gen := generators_generate_Sn n h
  -- We need to show that this implies the Cayley graph is connected.
  -- A Cayley graph is connected iff the generating set generates the group.
  -- This is a standard result.
  -- We can try to prove it or find it.
  -- Let's try to prove it using reachability.
  rw [SimpleGraph.connected_iff_exists_forall_reachable]
  use 1
  intro g
  -- We need to show there is a path from 1 to g.
  -- Since generators generate the group, g can be written as a product of generators.
  -- This product corresponds to a path in the Cayley graph.
  -- Since the subgroup generated by the generators is the entire symmetric group, there exists a sequence of generators that multiplies to g.
  obtain ⟨seq, hseq⟩ : ∃ seq : List (Equiv.Perm (Fin n)), (∀ s ∈ seq, s ∈ generators n) ∧ seq.prod = g := by
    have h_seq : g ∈ Subgroup.closure (generators n) := by
      aesop;
    have h_seq : ∀ g ∈ Subgroup.closure (generators n), ∃ seq : List (Equiv.Perm (Fin n)), (∀ s ∈ seq, s ∈ generators n) ∧ seq.prod = g := by
      refine fun g hg => Subgroup.closure_induction ?_ ?_ ?_ ?_ hg;
      · exact fun x hx => ⟨ [ x ], by simpa using hx ⟩;
      · exact ⟨ [ ], by simp +decide ⟩;
      · rintro x y hx hy ⟨ seq₁, hseq₁, rfl ⟩ ⟨ seq₂, hseq₂, rfl ⟩ ; exact ⟨ seq₁ ++ seq₂, by aesop ⟩;
      · rintro x hx ⟨ seq, hseq₁, hseq₂ ⟩;
        refine' ⟨ seq.reverse.map fun s => s⁻¹, _, _ ⟩ <;> simp_all +decide [ List.prod_inv_reverse ];
        · have h_inv : ∀ s ∈ generators n, s⁻¹ ∈ generators n := by
            unfold generators; aesop;
          exact fun s hs => by simpa using h_inv _ ( hseq₁ _ hs ) ;
        · rw [ ← hseq₂, List.prod_inv_reverse ];
    exact h_seq g ‹_›;
  -- By definition of the Cayley graph, there is an edge from $u$ to $u * s$ for any $u \in S_n$ and $s \in \text{generators } n$.
  have h_edge : ∀ u : Equiv.Perm (Fin n), ∀ s ∈ generators n, (cayleyGraph n).Adj u (u * s) := by
    intros u s hs;
    constructor;
    · simp +decide [ Equiv.Perm.ext_iff ];
      by_contra! h;
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ generators ];
      rcases hs with ( rfl | rfl | rfl ) <;> simp_all +decide [ Equiv.Perm.ext_iff ];
      · exact absurd ( h 0 ) ( by simp +decide [ Equiv.swap_apply_def ] );
      · simp_all +decide [ Fin.forall_fin_succ, Equiv.Perm.inv_eq_iff_eq ];
    · exact Or.inl ⟨ s, hs, rfl ⟩;
  -- By induction on the length of the sequence `seq`, we can show that there is a path from `u` to `u * seq.prod` for any `u`.
  have h_path_induction : ∀ (u : Equiv.Perm (Fin n)) (seq : List (Equiv.Perm (Fin n))), (∀ s ∈ seq, s ∈ generators n) → (cayleyGraph n).Reachable u (u * seq.prod) := by
    intros u seq hseq;
    -- We proceed by induction on the length of the sequence `seq`.
    induction' seq with s seq ih generalizing u;
    · simp +decide;
    · exact SimpleGraph.Reachable.trans ( h_edge u s ( hseq s ( by simp +decide ) ) |> SimpleGraph.Adj.reachable ) ( ih _ fun x hx => hseq x ( by simp +decide [ hx ] ) );
  simpa [ hseq.2 ] using h_path_induction 1 seq hseq.1

/-
Check distance to swap(0, 2) for n=4.
-/
#eval bfs_dist_to_target 4 (Equiv.swap 0 2) 1000

/-
The set of generators is closed under inversion.
-/
theorem generators_symmetric (n : ℕ) (h : 2 ≤ n) :
    ∀ g ∈ generators n, g⁻¹ ∈ generators n := by
  intro g hg
  have h1 : 1 < n := by linarith
  rw [generators] at hg ⊢
  simp [h1] at hg ⊢
  cases hg with
  | inl h_swap =>
    left
    rw [h_swap]
    simp
  | inr h_rot =>
    cases h_rot with
    | inl h_r =>
      right; right
      rw [h_r]
    | inr h_r_inv =>
      right; left
      rw [h_r_inv]
      simp

/-
The distance from 1 to the product of a list of generators is at most the length of the list.
-/
theorem dist_le_list_length (n : ℕ) (l : List (Equiv.Perm (Fin n))) (hl : ∀ g ∈ l, g ∈ generators n) :
    (cayleyGraph n).dist 1 l.prod ≤ l.length := by
      revert hl;
      induction' l using List.reverseRecOn with l ih;
      · aesop;
      · simp_all +decide [ SimpleGraph.dist ];
        intro hl;
        -- Since $ih$ is in the generators, there is an edge from $l.prod$ to $l.prod * ih$.
        have h_edge : (cayleyGraph n).Adj (l.prod) (l.prod * ih) := by
          unfold cayleyGraph;
          simp +decide [ hl, SimpleGraph.fromRel ];
          rintro rfl; specialize hl 1; simp_all +decide [ generators ] ;
          rcases n with ( _ | _ | n ) <;> simp_all +decide [ Equiv.Perm.ext_iff, Fin.forall_fin_succ ];
        have h_dist : (cayleyGraph n).edist 1 (l.prod * ih) ≤ (cayleyGraph n).edist 1 (l.prod) + 1 := by
          have h_dist : (cayleyGraph n).edist 1 (l.prod * ih) ≤ (cayleyGraph n).edist 1 (l.prod) + (cayleyGraph n).edist (l.prod) (l.prod * ih) := by
            exact?;
          exact h_dist.trans ( add_le_add_left ( by exact le_trans ( ciInf_le ⟨ 0, Set.forall_mem_range.mpr fun _ => by positivity ⟩ ( SimpleGraph.Walk.cons h_edge SimpleGraph.Walk.nil ) ) ( by norm_num ) ) _ );
        refine' le_trans ( ENat.toNat_le_toNat h_dist _ ) _;
        · exact ne_of_lt ( ENat.add_lt_top.mpr ⟨ lt_top_iff_ne_top.mpr ( by
            have h_connected : (cayleyGraph n).Connected := by
              by_cases hn : 2 ≤ n;
              · exact?;
              · interval_cases n <;> simp_all +decide [ SimpleGraph.connected_iff_exists_forall_reachable ];
            have := h_connected 1 l.prod;
            exact? ), ENat.coe_lt_top 1 ⟩ );
        · rw [ ENat.toNat_add ] ; aesop;
          · have h_connected : (cayleyGraph n).Connected := by
              by_cases hn : 2 ≤ n;
              · exact?;
              · interval_cases n <;> simp_all +decide [ SimpleGraph.connected_iff_exists_forall_reachable ];
            have := h_connected 1 l.prod;
            exact?;
          · decide +revert

#print SimpleGraph.Reachable

/-
If a set generates a group, the Cayley graph is connected.
-/
theorem connected_cayley_graph_of_closure_eq_top {G : Type*} [Group G] (S : Set G) (hS : Subgroup.closure S = ⊤) :
    (SimpleGraph.fromRel (fun g h => ∃ s ∈ S, h = g * s)).Connected := by
      refine' SimpleGraph.Connected.mk _;
      -- Since S generates G, any element g in G can be written as a product of elements from S and their inverses. Therefore, for any two elements g and h in G, there's a path from g to h by multiplying by elements of S or their inverses.
      have h_connected : ∀ g h : G, ∃ s : List G, (∀ x ∈ s, x ∈ S ∨ x⁻¹ ∈ S) ∧ g * List.prod s = h := by
        intro g h
        have h_prod : ∃ s : List G, (∀ x ∈ s, x ∈ S ∨ x⁻¹ ∈ S) ∧ List.prod s = g⁻¹ * h := by
          have h_prod : ∀ x : G, x ∈ Subgroup.closure S → ∃ s : List G, (∀ x ∈ s, x ∈ S ∨ x⁻¹ ∈ S) ∧ List.prod s = x := by
            refine' fun x hx => Subgroup.closure_induction _ _ _ _ hx;
            · exact fun x hx => ⟨ [ x ], by simpa using Or.inl hx ⟩;
            · exact ⟨ [ ], by simp +decide ⟩;
            · rintro x y hx hy ⟨ s, hs, rfl ⟩ ⟨ t, ht, rfl ⟩ ; exact ⟨ s ++ t, by aesop ⟩;
            · rintro x hx ⟨ s, hs, rfl ⟩;
              refine' ⟨ s.reverse.map fun x => x⁻¹, _, _ ⟩ <;> simp_all +decide [ List.prod_inv_reverse ];
              intro x hx; specialize hs x⁻¹; aesop;
          exact h_prod _ ( hS.symm ▸ Subgroup.mem_top _ );
        exact ⟨ h_prod.choose, h_prod.choose_spec.1, by rw [ h_prod.choose_spec.2, mul_inv_cancel_left ] ⟩;
      intro g h
      obtain ⟨s, hs⟩ := h_connected g h;
      have h_path : ∀ (g : G) (s : List G), (∀ x ∈ s, x ∈ S ∨ x⁻¹ ∈ S) → (SimpleGraph.fromRel (fun g h => ∃ s ∈ S, h = g * s)).Reachable g (g * s.prod) := by
        intro g s hs;
        induction' s with x s ih generalizing g <;> simp_all +decide [ SimpleGraph.fromRel ];
        convert SimpleGraph.Reachable.trans _ ( ih ( g * x ) ) using 1;
        · rw [ mul_assoc ];
        · by_cases h : g = g * x <;> simp_all +decide [ SimpleGraph.Reachable ];
          · exact ⟨ SimpleGraph.Walk.nil ⟩;
          · exact ⟨ SimpleGraph.Walk.cons ( by aesop ) SimpleGraph.Walk.nil ⟩;
      exact hs.2 ▸ h_path g s hs.1

/-
Left multiplication preserves reachability in the Cayley graph.
-/
theorem reachable_mul_left (n : ℕ) (g u v : Equiv.Perm (Fin n)) (h : (cayleyGraph n).Reachable u v) :
    (cayleyGraph n).Reachable (g * u) (g * v) := by
      -- Since the generators are closed under inversion, the reverse of each step in the path can be constructed using the inverses of the original generators.
      have h_inv : ∀ s ∈ generators n, s⁻¹ ∈ generators n := by
        unfold generators ; aesop ( simp_config := { decide := true } ) ;
      induction h;
      induction ‹_› ; aesop;
      rename_i u v w huv hvw ih;
      -- Since $u$ and $v$ are adjacent, there exists a generator $s$ such that $v = u * s$.
      obtain ⟨s, hs⟩ : ∃ s ∈ generators n, v = u * s := by
        unfold cayleyGraph at huv; aesop;
      -- Since $s$ is a generator, we have $g * u * s⁻¹ = g * v$.
      have h_adj : (cayleyGraph n).Adj (g * u) (g * u * s) := by
        unfold cayleyGraph; aesop;
      exact SimpleGraph.Reachable.trans ( SimpleGraph.Adj.reachable h_adj ) ( by aesop )

/-
Reachability in a Cayley graph with symmetric generators.
-/
theorem reachable_of_mem_closure {G : Type*} [Group G] (S : Set G) (hS : ∀ s ∈ S, s⁻¹ ∈ S) (g : G) (hg : g ∈ Subgroup.closure S) :
    (SimpleGraph.fromRel (fun a b => ∃ s ∈ S, b = a * s)).Reachable 1 g := by
      -- By definition of subgroup generated by S, g can be written as a product of elements from S and their inverses.
      have h_prod : ∃ l : List G, (∀ g ∈ l, g ∈ S ∪ S⁻¹) ∧ g = l.prod := by
        refine' Subgroup.closure_induction ( fun x hx => _ ) _ _ _ hg;
        · exact ⟨ [ x ], by aesop ⟩;
        · exact ⟨ [ ], by simp +decide ⟩;
        · rintro x y hx hy ⟨ l₁, hl₁, rfl ⟩ ⟨ l₂, hl₂, rfl ⟩ ; exact ⟨ l₁ ++ l₂, by aesop ⟩ ;
        · rintro x hx ⟨ l, hl, rfl ⟩;
          refine' ⟨ l.reverse.map ( fun g => g⁻¹ ), _, _ ⟩ <;> simp_all +decide [ List.prod_inv_reverse ];
          intro g hg; specialize hl g⁻¹; aesop;
      -- By induction on the length of the list l, we can show that the product of the elements in l is reachable from 1.
      have h_ind : ∀ l : List G, (∀ g ∈ l, g ∈ S ∪ S⁻¹) → (SimpleGraph.fromRel (fun a b => ∃ s ∈ S, b = a * s)).Reachable 1 l.prod := by
        intro l hl;
        induction' l using List.reverseRecOn with l g ih;
        · exact SimpleGraph.Reachable.refl _;
        · simp_all +decide [ SimpleGraph.fromRel ];
          refine' ih.trans _;
          by_cases hg : g = 1;
          · aesop;
          · cases' hl g ( Or.inr rfl ) with hg hg <;> simp_all +decide [ SimpleGraph.Reachable ];
            · exact ⟨ SimpleGraph.Walk.cons ( by aesop ) SimpleGraph.Walk.nil ⟩;
            · exact ⟨ SimpleGraph.Walk.cons ( by aesop ) SimpleGraph.Walk.nil ⟩;
      aesop
