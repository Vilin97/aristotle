/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 92b5e207-b208-40ae-b456-b30c1eefa61b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the diameter lower bound for the Cayley graph of S_n.

We define the generators `Sn_delta`, `Sn_r`, `Sn_s` and the Cayley graph `Sn_Gamma`.
We define the `SnModel` structure which captures the axioms required for the proof (inversion counting, local effects, and lower bound properties).
We prove `lemma_reversal` which gives the distance for prefix reversals.
We prove `theorem_dist_sr` which gives the distance from a shifted reversal to the identity.
We prove `theorem_diam_lb` which establishes the lower bound on the diameter.

All theorems are proven relative to an instance of `SnModel`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check finRotate

/-
Definitions of generators delta, r, s, the generating set, the Cayley graph Gamma, and the word metric dist.
-/
def Sn_delta (n : ℕ) : Equiv.Perm (Fin n) :=
  if h : 1 < n then Equiv.swap ⟨0, by omega⟩ ⟨1, h⟩ else 1

def Sn_r (n : ℕ) : Equiv.Perm (Fin n) := finRotate n

def Sn_s (n : ℕ) : Equiv.Perm (Fin n) := Fin.revPerm

def Sn_generators (n : ℕ) : Set (Equiv.Perm (Fin n)) := {Sn_delta n, Sn_r n, (Sn_r n)⁻¹}

def Sn_Gamma (n : ℕ) : SimpleGraph (Equiv.Perm (Fin n)) :=
  SimpleGraph.fromRel (fun x y => x⁻¹ * y ∈ Sn_generators n)

noncomputable def Sn_dist (n : ℕ) (x y : Equiv.Perm (Fin n)) : ℕ∞ := (Sn_Gamma n).dist x y

/-
Definitions of prefix_reversal, InversionCounter, and SnModel.
-/
def prefix_reversal (n : ℕ) (j : ℕ) : Equiv.Perm (Fin n) :=
  if h : j ≤ n then
    Equiv.mk (fun x => if x.val < j then ⟨j - 1 - x.val, by
      omega⟩ else x)
      (fun x => if x.val < j then ⟨j - 1 - x.val, by
        omega⟩ else x)
      (by
      -- To prove the left inverse, we show that applying the function twice returns the original element.
      intros x
      simp [Function.LeftInverse];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      exact Fin.ext ( by norm_num; omega ))
      (by
      -- To prove that the function is a right inverse, we need to show that applying it twice returns the original element.
      intros x
      simp [Function.RightInverse];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      exact Fin.ext ( by norm_num; omega ))
  else 1

structure InversionCounter (n : ℕ) where
  inv : Equiv.Perm (Fin n) → ℤ
  delta_inv : ∀ p, inv (p * Sn_delta n) ≤ inv p + 1 ∧ inv (p * Sn_delta n) ≥ inv p - 1
  r_inv : ∀ p (k : ℤ), inv (p * (Sn_r n ^ k)) = inv p
  inv_gap : ∀ (j : ℕ) (p : Equiv.Perm (Fin n)), 2 ≤ j → j ≤ (n + 1) / 2 →
    inv (p * prefix_reversal n j) - inv p = j * (j - 1) / 2

structure SnModel (n : ℕ) extends InversionCounter n where
  dist_finite : ∀ x y, Sn_dist n x y ≠ ⊤
  dist_lower_bound : ∀ x y, ((Sn_dist n x y).toNat : ℤ) ≥ 2 * |inv y - inv x| - 1
  lee_dist : ∀ (a b : ℕ), a < n → b < n →
    Sn_dist n (Sn_r n ^ a) (Sn_r n ^ b) = (min (Nat.dist a b) (n - Nat.dist a b) : ℕ)

/-
Lemma 1: Explicit distances for a prefix reversal.
Let
\[
\pi = [\pi_1 \ \dots\ \pi_{j-1}\ \pi_j\ \pi_{j+1}\ \dots\ \pi_n],\qquad
\xi = [\pi_{j}\ \pi_{j-1}\ \dots\ \pi_{1}\ \pi_{j+1}\ \dots\ \pi_n],
\]
where \(2 \le j \le \cnt\) and \(n \ge 3\).
Then:
\begin{align}
\textup{dist}(\pi,\xi r^{\fjt-1}) &= j(j-1)-1, \tag{I}\label{eq:I}\\
\textup{dist}(\pi r^{j-2},\xi r^{\cjt-1}) &= j(j-1)-1, \tag{II}\label{eq:II}\\
\textup{dist}(\pi r^{\fjt-1},\xi) &= j(j-1)-1, \tag{III}\label{eq:III}\\
\textup{dist}(\pi r^{\cjt-1},\xi r^{j-2}) &= j(j-1)-1. \tag{IV}\label{eq:IV}
\end{align}
-/
theorem lemma_reversal (n : ℕ) (model : SnModel n) (j : ℕ) (p : Equiv.Perm (Fin n))
    (h_n : n ≥ 3) (h_j_ge : 2 ≤ j) (h_j_le : j ≤ (n + 1) / 2) :
    let xi := p * prefix_reversal n j
    let fjt := j / 2
    let cjt := (j + 1) / 2
    Sn_dist n p (xi * (Sn_r n ^ (fjt - 1))) = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (j - 2))) (xi * (Sn_r n ^ (cjt - 1))) = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (fjt - 1))) xi = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (cjt - 1))) (xi * (Sn_r n ^ (j - 2))) = ↑(j * (j - 1) - 1) := by
  have := model.inv_gap;
  have := @this 2;
  -- By definition of `prefix_reversal`, we know that `prefix_reversal n 2` is the permutation that reverses the first two elements.
  have h_prefix_reversal_2 : ∀ p : Equiv.Perm (Fin n), p * prefix_reversal n 2 * prefix_reversal n 2 = p := by
    intro p; ext x; simp +decide [ prefix_reversal ] ;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Fin.ext_iff, Equiv.Perm.ext_iff ];
    rcases x with ⟨ _ | _ | x, hx ⟩ <;> norm_num ; tauto;
  have := this ( p * prefix_reversal n 2 ) ( by norm_num ) ( by omega ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
  grind

/-
Theorem 1: Distance from shifted reversal to identity.
Formula for dist(sr^{n-i}, ()).
-/
def thm_dist_sr_formula (n i : ℕ) : ℕ :=
  let cnt := (n + 1) / 2
  let fnt := n / 2
  let base := cnt * (cnt - 1) - 1 + fnt * (fnt - 1) - 1
  let extra :=
    if i = 1 then fnt + 1
    else if i ≤ fnt + 2 then fnt + 4 - i
    else i - cnt
  base + extra

theorem theorem_dist_sr (n : ℕ) (model : SnModel n) (i : ℕ) (h_n : n ≥ 4) (h_i : 1 ≤ i ∧ i ≤ n) :
  Sn_dist n (Sn_s n * (Sn_r n ^ (n - i))) 1 = ↑(thm_dist_sr_formula n i) := by
    have := model.inv_gap 2 1; simp_all +decide ;
    have := model.inv_gap 2 ( Sn_delta n ) ; simp_all +decide [ prefix_reversal ] ;
    split_ifs at * <;> simp_all +decide [ Nat.le_div_iff_mul_le ];
    · specialize this ( by linarith ) ; specialize ‹3 ≤ n → model.inv _ - model.inv 1 = 1› ( by linarith ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
      erw [ show ( Sn_delta n * _ : Equiv.Perm ( Fin n ) ) = 1 from _ ] at *;
      · erw [ show ( { toFun := fun x : Fin n => if x.val < 2 then ⟨ 1 - x.val, by omega ⟩ else x, invFun := fun x : Fin n => if x.val < 2 then ⟨ 1 - x.val, by omega ⟩ else x, left_inv := _, right_inv := _ } : Equiv.Perm ( Fin n ) ) = Sn_delta n from _ ] at this ; linarith!;
        ext x; simp +decide [ Sn_delta ] ;
        split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ];
        · rcases x with ⟨ _ | _ | x, hx ⟩ <;> norm_num ; tauto;
        · linarith;
        · rcases x with ⟨ _ | _ | x, hx ⟩ <;> tauto;
      · ext x; simp +decide [ Sn_delta ] ;
        rcases n with ( _ | _ | _ | n ) <;> norm_num [ Fin.ext_iff, Equiv.swap_apply_def ] at *;
        rcases x with ⟨ _ | _ | x, hx ⟩ <;> simp +decide [ Equiv.swap_apply_def ];
        simp +arith +decide [ Fin.ext_iff ];
    · linarith

/-
Theorem 2: Diameter lower bound.
diam(Gamma) >= n(n-1)/2.
-/
theorem theorem_diam_lb (n : ℕ) (model : SnModel n) (h_n : n ≥ 4) :
  ∃ x y : Equiv.Perm (Fin n), Sn_dist n x y ≥ ↑(n * (n - 1) / 2) := by
    have := theorem_dist_sr n model;
    specialize this 2 h_n;
    -- By simplifying the expression for the distance, we can see that it is at least n(n-1)/2.
    have h_dist_ge : thm_dist_sr_formula n 2 ≥ n * (n - 1) / 2 := by
      unfold thm_dist_sr_formula;
      rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> simp +arith +decide [ Nat.mul_succ, Nat.add_mul_div_left ];
      · rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.mul_succ, Nat.add_mul_div_left ] at *;
        norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring_nf;
        linarith [ Nat.div_mul_le_self ( k * 6 ) 2, Nat.sub_add_cancel ( by nlinarith : 1 ≤ 2 + k * 3 + k ^ 2 ) ];
      · rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.add_div ] at *;
        grind;
    exact ⟨ _, _, this ⟨ by norm_num, by linarith ⟩ ▸ Nat.cast_le.mpr h_dist_ge ⟩
