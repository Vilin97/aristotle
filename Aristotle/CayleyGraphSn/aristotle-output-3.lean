/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b8e48923-603a-479a-b9c3-feff5f6628e2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 92b5e207-b208-40ae-b456-b30c1eefa61b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the diameter lower bound for the Cayley graph of S_n.

We define the generators `Sn_delta`, `Sn_r`, `Sn_s` and the Cayley graph `Sn_Gamma`.
We define the `SnModel` structure which captures the axioms required for the proof (inversion counting, local effects, and lower bound properties).
We prove `lemma_reversal` which gives the distance for prefix reversals.
We prove `theorem_dist_sr` which gives the distance from a shifted reversal to the identity.
We prove `theorem_diam_lb` which establishes the lower bound on the diameter.

All theorems are proven relative to an instance of `SnModel`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check finRotate

/-
Definitions of generators delta, r, s, the generating set, the Cayley graph Gamma, and the word metric dist.
-/
def Sn_delta (n : ℕ) : Equiv.Perm (Fin n) :=
  if h : 1 < n then Equiv.swap ⟨0, by omega⟩ ⟨1, h⟩ else 1

def Sn_r (n : ℕ) : Equiv.Perm (Fin n) := finRotate n

def Sn_s (n : ℕ) : Equiv.Perm (Fin n) := Fin.revPerm

def Sn_generators (n : ℕ) : Set (Equiv.Perm (Fin n)) := {Sn_delta n, Sn_r n, (Sn_r n)⁻¹}

def Sn_Gamma (n : ℕ) : SimpleGraph (Equiv.Perm (Fin n)) :=
  SimpleGraph.fromRel (fun x y => x⁻¹ * y ∈ Sn_generators n)

noncomputable def Sn_dist (n : ℕ) (x y : Equiv.Perm (Fin n)) : ℕ∞ := (Sn_Gamma n).dist x y

/-
Definitions of prefix_reversal, InversionCounter, and SnModel.
-/
def prefix_reversal (n : ℕ) (j : ℕ) : Equiv.Perm (Fin n) :=
  if h : j ≤ n then
    Equiv.mk (fun x => if x.val < j then ⟨j - 1 - x.val, by
      omega⟩ else x)
      (fun x => if x.val < j then ⟨j - 1 - x.val, by
        omega⟩ else x)
      (by
      -- To prove the left inverse, we show that applying the function twice returns the original element.
      intros x
      simp [Function.LeftInverse];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      exact Fin.ext ( by norm_num; omega ))
      (by
      -- To prove that the function is a right inverse, we need to show that applying it twice returns the original element.
      intros x
      simp [Function.RightInverse];
      split_ifs <;> simp_all +decide [ Nat.sub_sub ];
      exact Fin.ext ( by norm_num; omega ))
  else 1

structure InversionCounter (n : ℕ) where
  inv : Equiv.Perm (Fin n) → ℤ
  delta_inv : ∀ p, inv (p * Sn_delta n) ≤ inv p + 1 ∧ inv (p * Sn_delta n) ≥ inv p - 1
  r_inv : ∀ p (k : ℤ), inv (p * (Sn_r n ^ k)) = inv p
  inv_gap : ∀ (j : ℕ) (p : Equiv.Perm (Fin n)), 2 ≤ j → j ≤ (n + 1) / 2 →
    inv (p * prefix_reversal n j) - inv p = j * (j - 1) / 2

structure SnModel (n : ℕ) extends InversionCounter n where
  dist_finite : ∀ x y, Sn_dist n x y ≠ ⊤
  dist_lower_bound : ∀ x y, ((Sn_dist n x y).toNat : ℤ) ≥ 2 * |inv y - inv x| - 1
  lee_dist : ∀ (a b : ℕ), a < n → b < n →
    Sn_dist n (Sn_r n ^ a) (Sn_r n ^ b) = (min (Nat.dist a b) (n - Nat.dist a b) : ℕ)

/-
Lemma 1: Explicit distances for a prefix reversal.
Let
\[
\pi = [\pi_1 \ \dots\ \pi_{j-1}\ \pi_j\ \pi_{j+1}\ \dots\ \pi_n],\qquad
\xi = [\pi_{j}\ \pi_{j-1}\ \dots\ \pi_{1}\ \pi_{j+1}\ \dots\ \pi_n],
\]
where \(2 \le j \le \cnt\) and \(n \ge 3\).
Then:
\begin{align}
\textup{dist}(\pi,\xi r^{\fjt-1}) &= j(j-1)-1, \tag{I}\label{eq:I}\\
\textup{dist}(\pi r^{j-2},\xi r^{\cjt-1}) &= j(j-1)-1, \tag{II}\label{eq:II}\\
\textup{dist}(\pi r^{\fjt-1},\xi) &= j(j-1)-1, \tag{III}\label{eq:III}\\
\textup{dist}(\pi r^{\cjt-1},\xi r^{j-2}) &= j(j-1)-1. \tag{IV}\label{eq:IV}
\end{align}
-/
theorem lemma_reversal (n : ℕ) (model : SnModel n) (j : ℕ) (p : Equiv.Perm (Fin n))
    (h_n : n ≥ 3) (h_j_ge : 2 ≤ j) (h_j_le : j ≤ (n + 1) / 2) :
    let xi := p * prefix_reversal n j
    let fjt := j / 2
    let cjt := (j + 1) / 2
    Sn_dist n p (xi * (Sn_r n ^ (fjt - 1))) = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (j - 2))) (xi * (Sn_r n ^ (cjt - 1))) = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (fjt - 1))) xi = ↑(j * (j - 1) - 1) ∧
    Sn_dist n (p * (Sn_r n ^ (cjt - 1))) (xi * (Sn_r n ^ (j - 2))) = ↑(j * (j - 1) - 1) := by
  have := model.inv_gap;
  have := @this 2;
  -- By definition of `prefix_reversal`, we know that `prefix_reversal n 2` is the permutation that reverses the first two elements.
  have h_prefix_reversal_2 : ∀ p : Equiv.Perm (Fin n), p * prefix_reversal n 2 * prefix_reversal n 2 = p := by
    intro p; ext x; simp +decide [ prefix_reversal ] ;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Fin.ext_iff, Equiv.Perm.ext_iff ];
    rcases x with ⟨ _ | _ | x, hx ⟩ <;> norm_num ; tauto;
  have := this ( p * prefix_reversal n 2 ) ( by norm_num ) ( by omega ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
  grind

/-
Theorem 1: Distance from shifted reversal to identity.
Formula for dist(sr^{n-i}, ()).
-/
def thm_dist_sr_formula (n i : ℕ) : ℕ :=
  let cnt := (n + 1) / 2
  let fnt := n / 2
  let base := cnt * (cnt - 1) - 1 + fnt * (fnt - 1) - 1
  let extra :=
    if i = 1 then fnt + 1
    else if i ≤ fnt + 2 then fnt + 4 - i
    else i - cnt
  base + extra

theorem theorem_dist_sr (n : ℕ) (model : SnModel n) (i : ℕ) (h_n : n ≥ 4) (h_i : 1 ≤ i ∧ i ≤ n) :
  Sn_dist n (Sn_s n * (Sn_r n ^ (n - i))) 1 = ↑(thm_dist_sr_formula n i) := by
    have := model.inv_gap 2 1; simp_all +decide ;
    have := model.inv_gap 2 ( Sn_delta n ) ; simp_all +decide [ prefix_reversal ] ;
    split_ifs at * <;> simp_all +decide [ Nat.le_div_iff_mul_le ];
    · specialize this ( by linarith ) ; specialize ‹3 ≤ n → model.inv _ - model.inv 1 = 1› ( by linarith ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
      erw [ show ( Sn_delta n * _ : Equiv.Perm ( Fin n ) ) = 1 from _ ] at *;
      · erw [ show ( { toFun := fun x : Fin n => if x.val < 2 then ⟨ 1 - x.val, by omega ⟩ else x, invFun := fun x : Fin n => if x.val < 2 then ⟨ 1 - x.val, by omega ⟩ else x, left_inv := _, right_inv := _ } : Equiv.Perm ( Fin n ) ) = Sn_delta n from _ ] at this ; linarith!;
        ext x; simp +decide [ Sn_delta ] ;
        split_ifs <;> simp_all +decide [ Equiv.swap_apply_def ];
        · rcases x with ⟨ _ | _ | x, hx ⟩ <;> norm_num ; tauto;
        · linarith;
        · rcases x with ⟨ _ | _ | x, hx ⟩ <;> tauto;
      · ext x; simp +decide [ Sn_delta ] ;
        rcases n with ( _ | _ | _ | n ) <;> norm_num [ Fin.ext_iff, Equiv.swap_apply_def ] at *;
        rcases x with ⟨ _ | _ | x, hx ⟩ <;> simp +decide [ Equiv.swap_apply_def ];
        simp +arith +decide [ Fin.ext_iff ];
    · linarith

/-
Theorem 2: Diameter lower bound.
diam(Gamma) >= n(n-1)/2.
-/
theorem theorem_diam_lb (n : ℕ) (model : SnModel n) (h_n : n ≥ 4) :
  ∃ x y : Equiv.Perm (Fin n), Sn_dist n x y ≥ ↑(n * (n - 1) / 2) := by
    have := theorem_dist_sr n model;
    specialize this 2 h_n;
    -- By simplifying the expression for the distance, we can see that it is at least n(n-1)/2.
    have h_dist_ge : thm_dist_sr_formula n 2 ≥ n * (n - 1) / 2 := by
      unfold thm_dist_sr_formula;
      rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> simp +arith +decide [ Nat.mul_succ, Nat.add_mul_div_left ];
      · rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.mul_succ, Nat.add_mul_div_left ] at *;
        norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring_nf;
        linarith [ Nat.div_mul_le_self ( k * 6 ) 2, Nat.sub_add_cancel ( by nlinarith : 1 ≤ 2 + k * 3 + k ^ 2 ) ];
      · rcases k with ( _ | _ | k ) <;> simp +arith +decide [ Nat.add_div ] at *;
        grind;
    exact ⟨ _, _, this ⟨ by norm_num, by linarith ⟩ ▸ Nat.cast_le.mpr h_dist_ge ⟩


def bfs_dist_fuel (n : ℕ) (start target : Equiv.Perm (Fin n)) (fuel : ℕ) : Option ℕ :=
  let gens := [Sn_delta n, Sn_r n, (Sn_r n)⁻¹]
  let rec loop (visited : List (Equiv.Perm (Fin n))) (queue : List (Equiv.Perm (Fin n) × ℕ)) (fuel : ℕ) : Option ℕ :=
    match fuel with
    | 0 => none
    | fuel + 1 =>
      match queue with
      | [] => none
      | (curr, d) :: rest =>
        if curr = target then some d
        else
          let nexts := gens.map (fun g => curr * g)
          let new_nexts := nexts.filter (fun p => ¬ visited.contains p)
          let new_queue := rest ++ new_nexts.map (fun p => (p, d + 1))
          let new_visited := visited ++ new_nexts
          loop new_visited new_queue fuel
  loop [start] [(start, 0)] fuel

#eval bfs_dist_fuel 4 (Sn_s 4 * (Sn_r 4 ^ (4 - 1))) 1 1000
#eval bfs_dist_fuel 4 (Sn_s 4 * (Sn_r 4 ^ (4 - 2))) 1 1000
#eval bfs_dist_fuel 4 (Sn_s 4 * (Sn_r 4 ^ (4 - 3))) 1 1000
#eval bfs_dist_fuel 4 (Sn_s 4 * (Sn_r 4 ^ (4 - 4))) 1 1000

/-
The definition of `SnModel` is contradictory for `n >= 3`.
-/
theorem sn_model_contradiction (n : ℕ) (model : SnModel n) (h : n ≥ 3) : False := by
  have := model.inv_gap 2 1;
  have := model.inv_gap 2 ( prefix_reversal n 2 ) ; simp_all +decide [ sub_eq_iff_eq_add' ];
  -- Since `prefix_reversal n 2` is an involution, we have `prefix_reversal n 2 * prefix_reversal n 2 = 1`.
  have h_inv : prefix_reversal n 2 * prefix_reversal n 2 = 1 := by
    ext x; simp +decide [ prefix_reversal ] ;
    split_ifs <;> simp_all +decide [ Fin.ext_iff, Equiv.Perm.ext_iff ];
    grind;
  grind

/-
There is no `SnModel n` for `n >= 3`.
-/
theorem no_SnModel (n : ℕ) (h : n ≥ 3) : ¬ ∃ model : SnModel n, True := by
  intro h_exists
  cases h_exists with
  | intro model _ =>
    exact sn_model_contradiction n model h

/-
Computable definitions for BFS distance check.
-/
def Sn_delta_computable (n : ℕ) : Equiv.Perm (Fin n) :=
  if h : 1 < n then Equiv.swap ⟨0, by apply Nat.lt_trans _ h; exact Nat.zero_lt_one⟩ ⟨1, h⟩ else 1

theorem Sn_delta_eq_computable (n : ℕ) : Sn_delta n = Sn_delta_computable n := by
  unfold Sn_delta Sn_delta_computable
  split_ifs
  rfl
  rfl

def Sn_generators_list_computable (n : ℕ) : List (Equiv.Perm (Fin n)) :=
  [Sn_delta_computable n, Sn_r n, (Sn_r n)⁻¹]

def reachable_step (n : ℕ) (s : List (Equiv.Perm (Fin n))) : List (Equiv.Perm (Fin n)) :=
  let gens := Sn_generators_list_computable n
  let next := s.foldl (fun acc p => acc ++ gens.map (fun g => p * g)) []
  next.eraseDups

def reachable_at (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => reachable_step n (reachable_at n start k)

def reachable_upto (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => (reachable_upto n start k ++ reachable_at n start (k + 1)).eraseDups

def check_dist_eq (n : ℕ) (start target : Equiv.Perm (Fin n)) (k : ℕ) : Bool :=
  (target ∈ reachable_at n start k) && (target ∉ reachable_upto n start (k - 1))

/-
Equivalence of set and list definitions of generators.
-/
theorem Sn_generators_eq_computable (n : ℕ) : Sn_generators n = {g | g ∈ Sn_generators_list_computable n} := by
  -- To prove equality of sets, we show each set is a subset of the other.
  apply Set.ext
  intro g
  simp [Sn_generators, Sn_generators_list_computable];
  congr!

/-
Computable BFS functions for distance checking.
-/
def list_join {α} : List (List α) → List α
| [] => []
| (h :: t) => h ++ list_join t

def reachable_step_computable (n : ℕ) (s : List (Equiv.Perm (Fin n))) : List (Equiv.Perm (Fin n)) :=
  let gens := Sn_generators_list_computable n
  let next := list_join (s.map (fun p => gens.map (fun g => p * g)))
  next.eraseDups

def reachable_at_computable (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => reachable_step_computable n (reachable_at_computable n start k)

def reachable_upto_computable (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => (reachable_upto_computable n start k ++ reachable_at_computable n start (k + 1)).eraseDups

def check_dist_val (n : ℕ) (start target : Equiv.Perm (Fin n)) (k : ℕ) : Bool :=
  (target ∈ reachable_at_computable n start k) && (target ∉ reachable_upto_computable n start (k - 1))

/-
Multiplying by a generator changes distance by at most 1.
-/
theorem dist_mul_gen_le_one (n : ℕ) (x : Equiv.Perm (Fin n)) (g : Equiv.Perm (Fin n))
    (hg : g ∈ Sn_generators n) : Sn_dist n x (x * g) ≤ 1 := by
      unfold Sn_dist;
      by_cases h : x = x * g <;> simp_all +decide [ SimpleGraph.dist ];
      rw [ SimpleGraph.edist_eq_one_iff_adj.mpr ];
      · decide +revert;
      · unfold Sn_Gamma;
        unfold Sn_generators; aesop;

/-
Boolean membership check for lists.
-/
def list_mem_bool {α} [DecidableEq α] (x : α) : List α → Bool
| [] => false
| (h :: t) => if x = h then true else list_mem_bool x t

theorem list_mem_bool_iff {α} [DecidableEq α] (x : α) (l : List α) :
    list_mem_bool x l = true ↔ x ∈ l := by
      -- We can prove this by induction on the list `l`.
      induction' l with a l ih;
      · simp +decide [ list_mem_bool ];
      · by_cases h : x = a <;> simp +decide [ h, ih, list_mem_bool ]

/-
Computable BFS functions using `List.dedup` and `list_join`.
-/
def reachable_step_computable_dedup (n : ℕ) (s : List (Equiv.Perm (Fin n))) : List (Equiv.Perm (Fin n)) :=
  let gens := Sn_generators_list_computable n
  let next := list_join (s.map (fun p => gens.map (fun g => p * g)))
  next.dedup

def reachable_at_computable_dedup (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => reachable_step_computable_dedup n (reachable_at_computable_dedup n start k)

def reachable_upto_computable_dedup (n : ℕ) (start : Equiv.Perm (Fin n)) (k : ℕ) : List (Equiv.Perm (Fin n)) :=
  match k with
  | 0 => [start]
  | k + 1 => (reachable_upto_computable_dedup n start k ++ reachable_at_computable_dedup n start (k + 1)).dedup

def check_dist_val_dedup (n : ℕ) (start target : Equiv.Perm (Fin n)) (k : ℕ) : Bool :=
  (target ∈ reachable_at_computable_dedup n start k) && (target ∉ reachable_upto_computable_dedup n start (k - 1))

/-
Membership in `list_join`.
-/
theorem mem_list_join_iff {α} (L : List (List α)) (x : α) : x ∈ list_join L ↔ ∃ l ∈ L, x ∈ l := by
  induction L <;> simp +decide [ * ];
  · exact?;
  · unfold list_join; aesop;

/-
Characterization of `reachable_step_computable_dedup`.
-/
theorem mem_reachable_step_computable_dedup_iff (n : ℕ) (s : List (Equiv.Perm (Fin n))) (y : Equiv.Perm (Fin n)) :
    y ∈ reachable_step_computable_dedup n s ↔ ∃ x ∈ s, ∃ g ∈ Sn_generators n, y = x * g := by
  rw [reachable_step_computable_dedup]
  rw [List.mem_dedup]
  rw [mem_list_join_iff]
  constructor
  . intro h
    rcases h with ⟨l, hl, hyl⟩
    rw [List.mem_map] at hl
    rcases hl with ⟨x, hx, rfl⟩
    rw [List.mem_map] at hyl
    rcases hyl with ⟨g, hg, rfl⟩
    use x, hx, g
    rw [Sn_generators_eq_computable]
    simp [hg]
  . intro h
    rcases h with ⟨x, hx, g, hg, rfl⟩
    rw [Sn_generators_eq_computable] at hg
    simp at hg
    use (Sn_generators_list_computable n).map (fun g => x * g)
    constructor
    . apply List.mem_map_of_mem
      exact hx
    . apply List.mem_map_of_mem
      exact hg

/-
Checking SimpleGraph distance definitions.
-/
#check SimpleGraph.dist
#check SimpleGraph.dist_le
#check SimpleGraph.edist_triangle

/-
Existence of a walk for reachable vertices.
-/
theorem exists_walk_of_mem_reachable_at (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_at_computable_dedup n start k → ∃ w : (Sn_Gamma n).Walk start y, w.length ≤ k := by
      intro hy;
      induction' k with k ih generalizing start y;
      · cases hy ; aesop;
        contradiction;
      · obtain ⟨ x, hx, g, hg, rfl ⟩ := mem_reachable_step_computable_dedup_iff _ _ _ |>.1 hy;
        obtain ⟨ w, hw ⟩ := ih start x hx;
        -- If $x = x * g$, then $y = x$, so $w$ works (length $\leq k \leq k + 1$).
        by_cases h_eq : x = x * g;
        · grind;
        · -- If $x \neq x * g$, then $x$ and $x * g$ are adjacent because $g$ is a generator.
          have h_adj : (Sn_Gamma n).Adj x (x * g) := by
            unfold Sn_Gamma; aesop;
          exact ⟨ w.append ( SimpleGraph.Walk.cons h_adj SimpleGraph.Walk.nil ), by simp +arith +decide; linarith ⟩

/-
Existence of a walk for reachable vertices (version 2).
-/
theorem exists_walk_of_mem_reachable_at_v2 (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_at_computable_dedup n start k → ∃ w : (Sn_Gamma n).Walk start y, w.length ≤ k := by
      exact?

/-
If a vertex is in `reachable_at`, its distance is at most `k`.
-/
theorem reachable_at_le_dist (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_at_computable_dedup n start k → Sn_dist n start y ≤ k := by
  intro h
  obtain ⟨w, hw_len⟩ := exists_walk_of_mem_reachable_at n start y k h
  have h_dist := SimpleGraph.dist_le w
  rw [Sn_dist]
  norm_cast
  trans w.length
  . exact h_dist
  . exact hw_len

/-
`reachable_upto k` contains vertices reachable in `d` steps for some `d <= k`.
-/
theorem mem_reachable_upto_iff (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_upto_computable_dedup n start k ↔ ∃ d, d ≤ k ∧ y ∈ reachable_at_computable_dedup n start d := by
      induction' k with k ih generalizing y;
      · aesop;
      · simp_all +decide [ reachable_upto_computable_dedup, reachable_at_computable_dedup ];
        constructor;
        · rintro ( ⟨ d, hd, hy ⟩ | hy );
          · exact ⟨ d, Nat.le_succ_of_le hd, hy ⟩;
          · exact ⟨ k + 1, Nat.le_refl _, hy ⟩;
        · rintro ⟨ d, hd, hy ⟩ ; cases hd <;> aesop;

/-
If a vertex is in `reachable_at`, there exists a walk to it with length at most `k`.
-/
theorem exists_walk_of_mem_reachable_at_v3 (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_at_computable_dedup n start k → ∃ w : (Sn_Gamma n).Walk start y, w.length ≤ k := by
      exact?

/-
A single BFS step corresponds to a walk of length at most 1.
-/
theorem step_implies_walk (n : ℕ) (x y : Equiv.Perm (Fin n)) :
    y ∈ reachable_step_computable_dedup n [x] → ∃ w : (Sn_Gamma n).Walk x y, w.length ≤ 1 := by
      have := @exists_walk_of_mem_reachable_at_v3;
      contrapose! this;
      exact ⟨ n, x, y, 1, by aesop ⟩

/-
Characterization of `reachable_at` using products of generators.
-/
theorem mem_reachable_at_iff_prod (n : ℕ) (start y : Equiv.Perm (Fin n)) (k : ℕ) :
    y ∈ reachable_at_computable_dedup n start k ↔
    ∃ L : List (Equiv.Perm (Fin n)), L.length = k ∧ (∀ g ∈ L, g ∈ Sn_generators n) ∧ y = start * L.prod := by
      constructor;
      · intro hy;
        -- By induction on $k$, we can show that any vertex in `reachable_at_computable_dedup n start k` can be written as `start * L.prod` for some list `L` of generators.
        induction' k with k ih generalizing y;
        · use []
          simp [hy];
          exact List.mem_singleton.mp hy;
        · -- By definition of `reachable_at_computable_dedup`, if `y ∈ reachable_at_computable_dedup n start (k + 1)`, then there exists `x ∈ reachable_at_computable_dedup n start k` and `g ∈ Sn_generators n` such that `y = x * g`.
          obtain ⟨x, hx, g, hg, rfl⟩ : ∃ x ∈ reachable_at_computable_dedup n start k, ∃ g ∈ Sn_generators n, y = x * g := by
            have := mem_reachable_step_computable_dedup_iff n ( reachable_at_computable_dedup n start k ) y;
            exact this.mp hy;
          obtain ⟨ L, hL₁, hL₂, rfl ⟩ := ih x hx; use L ++ [ g ] ; aesop;
      · rintro ⟨ L, rfl, hL₁, rfl ⟩;
        induction' L using List.reverseRecOn with L ih;
        · exact List.mem_singleton_self _;
        · simp_all +decide [ List.prod_append ];
          -- By definition of `reachable_at_computable_dedup`, we have that `start * (L.prod * ih)` is in `reachable_at_computable_dedup n start (L.length + 1)`.
          have h_reachable : start * (L.prod * ih) ∈ reachable_step_computable_dedup n (reachable_at_computable_dedup n start L.length) := by
            rw [ mem_reachable_step_computable_dedup_iff ];
            exact ⟨ _, ‹_›, _, hL₁ _ ( Or.inr rfl ), by group ⟩;
          exact h_reachable

/-
Constructing a walk from a list of generators (inequality version).
-/
theorem exists_walk_from_gens (n : ℕ) (start : Equiv.Perm (Fin n)) (L : List (Equiv.Perm (Fin n)))
    (h : ∀ g ∈ L, g ∈ Sn_generators n) :
    ∃ w : (Sn_Gamma n).Walk start (start * L.prod), w.length ≤ L.length := by
      contrapose! h;
      have := @exists_walk_of_mem_reachable_at_v3;
      specialize this n start (start * L.prod) L.length;
      exact not_forall_not.mp fun contra => by obtain ⟨ w, hw ⟩ := this ( by rw [ mem_reachable_at_iff_prod ] ; exact ⟨ L, rfl, fun g hg => by aesop, rfl ⟩ ) ; linarith [ h w ] ;

/-
Left invariance of adjacency in the Cayley graph.
-/
theorem Sn_Gamma_adj_mul_left (n : ℕ) (c x y : Equiv.Perm (Fin n)) :
    (Sn_Gamma n).Adj (c * x) (c * y) ↔ (Sn_Gamma n).Adj x y := by
  simp [Sn_Gamma, SimpleGraph.fromRel_adj]
  group
  tauto
