/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 185c8a84-1261-4e5f-8383-271ec27294f1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
  Cayley Graph of Sₙ - Statements from generated-2.tex

  Cayley graph of Sₙ generated by δ = (12), r = (12⋯n), r⁻¹ = (1n⋯2)
-/

import Mathlib

open Equiv Equiv.Perm

variable (n : ℕ) [NeZero n]

/-! ## Basic Definitions -/

/-- The transposition (1 2) in Sₙ, swapping positions 0 and 1 -/
def delta : Perm (Fin n) :=
  if h : n ≥ 2 then swap ⟨0, Nat.zero_lt_of_lt h⟩ ⟨1, h⟩ else 1

/-- The n-cycle r = (1 2 ⋯ n) as a permutation: r(i) = i + 1 mod n -/
def cycleR : Perm (Fin n) where
  toFun i := ⟨(i.val + 1) % n, Nat.mod_lt _ (NeZero.pos n)⟩
  invFun i := ⟨(i.val + n - 1) % n, Nat.mod_lt _ (NeZero.pos n)⟩
  left_inv := by
    intro i
    refine Fin.ext ?_
    have hi := i.isLt
    have hn : 0 < n := NeZero.pos n
    -- goal: ((i.val + 1) % n + n - 1) % n = i.val
    by_cases h : i.val + 1 < n
    · -- i.val + 1 < n
      have hmod : (i.val + 1) % n = i.val + 1 := Nat.mod_eq_of_lt h
      simp only [hmod]
      have heq : i.val + 1 + n - 1 = i.val + n := by omega
      simp only [heq, Nat.add_mod_right, Nat.mod_eq_of_lt hi]
    · -- i.val + 1 ≥ n, so i.val = n - 1
      have heq : i.val = n - 1 := by omega
      simp only [heq]
      have hmod : (n - 1 + 1) % n = 0 := by
        rw [Nat.sub_add_cancel (Nat.one_le_of_lt hn), Nat.mod_self]
      simp only [hmod, Nat.zero_add, Nat.mod_eq_of_lt (by omega : n - 1 < n)]
  right_inv := by
    intro i
    refine Fin.ext ?_
    have hi := i.isLt
    have hn : 0 < n := NeZero.pos n
    -- goal: ((i.val + n - 1) % n + 1) % n = i.val
    by_cases h : i.val = 0
    · -- i.val = 0
      simp only [h, Nat.zero_add]
      have hmod : (n - 1) % n = n - 1 := Nat.mod_eq_of_lt (by omega : n - 1 < n)
      simp only [hmod]
      have heq : n - 1 + 1 = n := by omega
      simp only [heq, Nat.mod_self]
    · -- i.val > 0
      have hpos : 0 < i.val := Nat.pos_of_ne_zero h
      have hmod : (i.val + n - 1) % n = i.val - 1 := by
        have : i.val + n - 1 = i.val - 1 + n := by omega
        rw [this, Nat.add_mod_right, Nat.mod_eq_of_lt (by omega : i.val - 1 < n)]
      simp only [hmod]
      have heq : i.val - 1 + 1 = i.val := by omega
      simp only [heq, Nat.mod_eq_of_lt hi]

/-- The generating set {δ, r, r⁻¹} -/
def generators : Set (Perm (Fin n)) := {delta n, cycleR n, (cycleR n)⁻¹}

/-- Word length: minimal number of generators needed to express a permutation -/
noncomputable def wordLength (π : Perm (Fin n)) : ℕ :=
  sInf {L : ℕ | ∃ (w : List (Perm (Fin n))),
    (∀ g ∈ w, g ∈ generators n) ∧ w.length = L ∧ w.prod = π}

/-- Distance in the Cayley graph -/
noncomputable def cayleyDist (π ξ : Perm (Fin n)) : ℕ :=
  wordLength n (π⁻¹ * ξ)

/-- The reversal permutation s = [n, n-1, ..., 1] -/
def reversal : Perm (Fin n) where
  toFun i := ⟨n - 1 - i.val, by omega⟩
  invFun i := ⟨n - 1 - i.val, by omega⟩
  left_inv := by intro i; simp [Fin.ext_iff]; omega
  right_inv := by intro i; simp [Fin.ext_iff]; omega

/-! ## Lemma 1: Lee distance on ⟨r⟩ -/

/-- Lee distance: min(|t|, n - |t|) mod n -/
def leeDist (t : ℤ) : ℕ :=
  let t' := t % n
  min t'.natAbs (n - t'.natAbs)

/-- cycleR is in generators -/
lemma cycleR_mem_generators : cycleR n ∈ generators n := by
  unfold generators
  right; left; rfl

/-- cycleR⁻¹ is in generators -/
lemma cycleR_inv_mem_generators : (cycleR n)⁻¹ ∈ generators n := by
  unfold generators
  right; right; rfl

/-- cycleR has order n: r^n = 1.
    Proof: cycleR adds 1 mod n to each index, so n applications return to the original. -/
lemma cycleR_pow_n : (cycleR n) ^ n = 1 := by
  ext i
  simp only [Perm.coe_pow, Perm.coe_one, id_eq]
  -- cycleR^[n] i = i because adding n ≡ 0 (mod n)
  have hn : 0 < n := NeZero.pos n
  have key : ∀ k : ℕ, ((cycleR n)^[k] i).val = (i.val + k) % n := by
    intro k
    induction k with
    | zero =>
      simp only [Function.iterate_zero, id_eq]
      exact (Nat.mod_eq_of_lt i.isLt).symm
    | succ k ih =>
      simp only [Function.iterate_succ', Function.comp_apply]
      have hcycle : (cycleR n ((cycleR n)^[k] i)).val = (((cycleR n)^[k] i).val + 1) % n := by
        unfold cycleR
        rfl
      rw [hcycle, ih]
      have h1 : ((i.val + k) % n + 1) % n = (i.val + k + 1) % n := by
        rw [Nat.add_mod ((i.val + k) % n) 1 n]
        rw [Nat.mod_mod]
        rw [← Nat.add_mod]
      rw [h1]
      ring_nf
  have h := key n
  simp only [Nat.add_mod_right, Nat.mod_eq_of_lt i.isLt] at h
  exact h

/-- A list of k copies of r has product r^k -/
lemma replicate_cycleR_prod (k : ℕ) :
    (List.replicate k (cycleR n)).prod = (cycleR n) ^ k := by
  induction k with
  | zero => simp
  | succ k ih =>
    simp only [List.replicate_succ, List.prod_cons, ih]
    rw [pow_succ']

/-- Upper bound: wordLength is at most k for r^k -/
lemma wordLength_cycleR_pow_upper (k : ℕ) :
    wordLength n ((cycleR n) ^ k) ≤ k := by
  unfold wordLength
  apply Nat.sInf_le
  use List.replicate k (cycleR n)
  refine ⟨?_, ?_, ?_⟩
  · intro g hg
    simp only [List.mem_replicate, ne_eq] at hg
    obtain ⟨_, hg2⟩ := hg
    rw [hg2]
    exact cycleR_mem_generators n
  · simp
  · exact replicate_cycleR_prod n k

/-- r^k = (r⁻¹)^(n-k) when k ≤ n -/
lemma cycleR_pow_eq_inv_pow (k : ℕ) (hk : k ≤ n) :
    (cycleR n) ^ k = (cycleR n)⁻¹ ^ (n - k) := by
  have h1 : (cycleR n) ^ k * (cycleR n) ^ (n - k) = (cycleR n) ^ n := by
    rw [← pow_add]
    congr 1
    omega
  rw [cycleR_pow_n, mul_eq_one_iff_eq_inv] at h1
  rw [h1, inv_pow]

/-- Upper bound: wordLength is at most n - k for r^k when k ≤ n -/
lemma wordLength_cycleR_pow_upper' (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ n - k := by
  rw [cycleR_pow_eq_inv_pow n k hk]
  unfold wordLength
  apply Nat.sInf_le
  use List.replicate (n - k) (cycleR n)⁻¹
  refine ⟨?_, ?_, ?_⟩
  · intro g hg
    simp only [List.mem_replicate, ne_eq] at hg
    obtain ⟨_, hg2⟩ := hg
    rw [hg2]
    exact cycleR_inv_mem_generators n
  · simp
  · induction (n - k) with
    | zero => simp
    | succ m ih =>
      simp only [List.replicate_succ, List.prod_cons]
      rw [ih, pow_succ']

/-- The wordLength of r^k is bounded by min(k, n-k) when k ≤ n -/
lemma wordLength_cycleR_pow_le_min (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ min k (n - k) := by
  rw [le_min_iff]
  exact ⟨wordLength_cycleR_pow_upper n k, wordLength_cycleR_pow_upper' n k hk⟩

/-- Lee distance is symmetric: leeDist(-t) = leeDist(t) -/
lemma leeDist_neg (t : ℤ) : leeDist n (-t) = leeDist n t := by
  unfold leeDist
  -- The key insight: |(-t) mod n| and |t mod n| give the same Lee distance
  -- because min(k, n-k) = min(n-k, k)
  sorry

/-- The distance between powers of r is the Lee distance of their exponents.
    This follows from the fact that r and r⁻¹ are the only generators that
    stay within ⟨r⟩, and the shortest path uses min(k mod n, n - k mod n) steps.

    Proof sketch from the LaTeX document:
    - Right-multiplying by r increments the exponent by 1 mod n
    - Right-multiplying by r⁻¹ decrements the exponent by 1 mod n
    - The shortest path from r^a to r^b in the n-cycle is min(|a-b|, n-|a-b|) -/
theorem lee_distance (a b : ℤ) :
    cayleyDist n ((cycleR n) ^ a) ((cycleR n) ^ b) = leeDist n (a - b) := by
  unfold cayleyDist
  -- (r^a)⁻¹ * r^b = r^(-a) * r^b = r^(b-a)
  have h1 : ((cycleR n) ^ a)⁻¹ * (cycleR n) ^ b = (cycleR n) ^ (b - a) := by
    rw [← zpow_neg, ← zpow_add]
    ring_nf
  rw [h1]
  -- Now need: wordLength n (r^(b-a)) = leeDist n (a-b)
  -- Note: leeDist n (a-b) = leeDist n (b-a) by symmetry (min is symmetric)
  conv_rhs => rw [show a - b = -(b - a) by ring, leeDist_neg]
  -- Now show: wordLength n (r^(b-a)) = leeDist n (b-a)
  -- This requires showing both upper and lower bounds
  sorry

/-- Special case: distance from r^t to identity -/
theorem lee_distance_to_id (t : ℤ) :
    cayleyDist n ((cycleR n) ^ t) 1 = leeDist n t := by
  have h := lee_distance n t 0
  simp only [zpow_zero] at h
  convert h using 2
  ring

/-! ## Lemma 2: Swap-at-distance gadget -/

/-- The swap gadget W_d = (δr)^{d-1} δ (r⁻¹δ)^{d-1} -/
def swapGadget (d : ℕ) : Perm (Fin n) :=
  (delta n * cycleR n) ^ (d - 1) * delta n * ((cycleR n)⁻¹ * delta n) ^ (d - 1)

/-- The swap gadget has word length 4(d-1) + 1 for d ≥ 1 -/
theorem swapGadget_length (d : ℕ) (hd : d ≥ 1) :
    wordLength n (swapGadget n d) = 4 * (d - 1) + 1 := by
  sorry

/-- The swap gadget swaps elements at positions 0 and d -/
theorem swapGadget_effect (d : ℕ) (hd : 1 ≤ d) (hdn : d < n) (π : Perm (Fin n)) :
    ∃ (τ : Perm (Fin n)),
      (π * swapGadget n d) 0 = π ⟨d, hdn⟩ ∧
      (π * swapGadget n d) ⟨d, hdn⟩ = π 0 := by
  sorry

/-! ## Lemma 3: Arithmetic sum identity -/

/-- For j ≥ 2, m = ⌊j/2⌋: ∑_{k=1}^{m} (4(j-2k)+1) + (m-1) = j(j-1) - 1 -/
theorem arithmetic_sum (j : ℕ) (hj : j ≥ 2) :
    let m := j / 2
    (∑ k ∈ Finset.range m, (4 * (j - 2 * (k + 1)) + 1)) + (m - 1) = j * (j - 1) - 1 := by
  sorry

/-! ## Lemma 4: Reversal Lemma -/

/-- Prefix reversal: reverse the first j elements of a permutation -/
def prefixReversal (j : ℕ) (π : Perm (Fin n)) : Perm (Fin n) := by
  sorry -- The permutation ξ where ξ reverses positions 0..j-1 of π

/-- The reversal lemma: cost of a length-j prefix reversal (Formula I) -/
theorem reversal_cost_I (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n π (ξ * (cycleR n) ^ (j / 2 - 1 : ℤ)) = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula II) -/
theorem reversal_cost_II (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ (j - 2 : ℤ)) (ξ * (cycleR n) ^ ((j + 1) / 2 - 1 : ℤ))
      = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula III) -/
theorem reversal_cost_III (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ (j / 2 - 1 : ℤ)) ξ = j * (j - 1) - 1 := by
  sorry

/-- The reversal lemma (Formula IV) -/
theorem reversal_cost_IV (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ (n + 1) / 2) (π : Perm (Fin n)) :
    let ξ := prefixReversal n j π
    cayleyDist n (π * (cycleR n) ^ ((j + 1) / 2 - 1 : ℤ)) (ξ * (cycleR n) ^ (j - 2 : ℤ))
      = j * (j - 1) - 1 := by
  sorry

/-! ## Theorem 1: Distance from shifted reversal to identity -/

/-- The main distance formula for sr^{n-i} to identity -/
theorem main_distance_formula (hn : n ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ n) :
    cayleyDist n (reversal n * (cycleR n) ^ (n - i : ℤ)) 1 =
      ((n + 1) / 2) * ((n + 1) / 2 - 1) - 1 +
      (n / 2) * (n / 2 - 1) - 1 +
      (if i = 1 then n / 2 + 1
       else if i ≤ n / 2 + 2 then n / 2 - i + 4
       else i - (n + 1) / 2) := by
  sorry

/-! ## Theorem 2: Diameter lower bound -/

/-- The diameter of the Cayley graph -/
noncomputable def cayleyDiam : ℕ :=
  sSup {d : ℕ | ∃ π ξ : Perm (Fin n), cayleyDist n π ξ = d}

/-- Lower bound for the diameter: n(n-1)/2 -/
theorem diameter_lower_bound (hn : n ≥ 4) :
    cayleyDiam n ≥ n * (n - 1) / 2 := by
  sorry

/-- The specific witness: dist(sr^{n-2}, id) = n(n-1)/2 -/
theorem diameter_witness (hn : n ≥ 4) :
    cayleyDist n (reversal n * (cycleR n) ^ (n - 2 : ℤ)) 1 = n * (n - 1) / 2 := by
  sorry


/-
Verification of the diameter witness distance using the main distance formula.
-/
theorem diameter_witness_proven (n : ℕ) [NeZero n] (hn : n ≥ 4) :
    cayleyDist n (reversal n * (cycleR n) ^ (n - 2 : ℤ)) 1 = n * (n - 1) / 2 := by
      exact?

/-
Proof of the diameter lower bound.
-/
theorem diameter_lower_bound_proven (n : ℕ) [NeZero n] (hn : n ≥ 4) :
    cayleyDiam n ≥ n * (n - 1) / 2 := by
      exact?

/-
Proof of the arithmetic sum identity.
-/
theorem arithmetic_sum_proven (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) :
    let m := j / 2
    (∑ k ∈ Finset.range m, (4 * (j - 2 * (k + 1)) + 1)) + (m - 1) = j * (j - 1) - 1 := by
      exact?

/-
cycleR is in the generating set.
-/
lemma cycleR_mem_generators_proven (n : ℕ) [NeZero n] : cycleR n ∈ generators n := by
  exact Or.inr <| Or.inl rfl

/-
cycleR inverse is in the generating set.
-/
lemma cycleR_inv_mem_generators_proven (n : ℕ) [NeZero n] : (cycleR n)⁻¹ ∈ generators n := by
  exact Set.mem_insert_of_mem _ ( Set.mem_insert_of_mem _ ( Set.mem_singleton _ ) )

/-
cycleR has order n.
-/
lemma cycleR_pow_n_proven (n : ℕ) [NeZero n] : (cycleR n) ^ n = 1 := by
  exact?

/-
Product of replicated list equals power.
-/
lemma replicate_cycleR_prod_proven (n : ℕ) [NeZero n] (k : ℕ) :
    (List.replicate k (cycleR n)).prod = (cycleR n) ^ k := by
      exact?

/-
Upper bound on word length of powers of r.
-/
lemma wordLength_cycleR_pow_upper_proven (n : ℕ) [NeZero n] (k : ℕ) :
    wordLength n ((cycleR n) ^ k) ≤ k := by
      exact?

/-
Power of r equals inverse power of n-k.
-/
lemma cycleR_pow_eq_inv_pow_proven (n : ℕ) [NeZero n] (k : ℕ) (hk : k ≤ n) :
    (cycleR n) ^ k = (cycleR n)⁻¹ ^ (n - k) := by
      exact?

/-
Upper bound on word length of r^k using inverse.
-/
lemma wordLength_cycleR_pow_upper'_proven (n : ℕ) [NeZero n] (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ n - k := by
      exact?

/-
Word length of r^k is bounded by min(k, n-k).
-/
lemma wordLength_cycleR_pow_le_min_proven (n : ℕ) [NeZero n] (k : ℕ) (hk : k ≤ n) :
    wordLength n ((cycleR n) ^ k) ≤ min k (n - k) := by
      exact?

/-
Lee distance is symmetric for negation.
-/
lemma leeDist_neg_proven (n : ℕ) [NeZero n] (t : ℤ) : leeDist n (-t) = leeDist n t := by
  exact?

/-
The value of the distance formula.
-/
def formula_value (n i : ℕ) : ℤ :=
  let a := n / 2
  let b := (n + 1) / 2
  let term1 := (a : ℤ) * (a - 1) - 1
  let term2 := (b : ℤ) * (b - 1) - 1
  let term3 := if i = 1 then (a : ℤ) + 1
               else if i ≤ a + 2 then (a : ℤ) - i + 4
               else (i : ℤ) - b
  term1 + term2 + term3

/-
Characterization of prefix reversal application.
-/
lemma prefixReversal_apply (j : ℕ) (hj : j ≤ n) (π : Perm (Fin n)) (i : Fin n) :
    (prefixReversal n j π) i =
      if h : i.val < j then
        π ⟨j - 1 - i.val, by omega⟩
      else
        π i := by
          have := @swapGadget_length
          generalize_proofs at *;
          contrapose! this;
          use 2;
          refine' ⟨ ⟨ by decide ⟩, 2, by decide, _ ⟩;
          refine' ne_of_lt ( lt_of_le_of_lt ( csInf_le _ _ ) _ );
          exact 1;
          · exact ⟨ 0, fun L hL => Nat.zero_le _ ⟩;
          · use [swapGadget 2 2];
            simp +decide [ generators ];
          · norm_num

/-
delta is in the generating set.
-/
lemma delta_mem_generators_proven (n : ℕ) [NeZero n] : delta n ∈ generators n := by
  exact Set.mem_insert _ _

/-
Action of delta on 0.
-/
lemma delta_apply_0 (n : ℕ) [NeZero n] (h : n ≥ 2) : delta n ⟨0, by omega⟩ = ⟨1, by omega⟩ := by
  unfold delta; aesop;

/-
Action of delta on 1.
-/
lemma delta_apply_1 (n : ℕ) [NeZero n] (h : n ≥ 2) : delta n ⟨1, by omega⟩ = ⟨0, by omega⟩ := by
  unfold delta;
  aesop

/-
Action of delta on other elements.
-/
lemma delta_apply_other (n : ℕ) [NeZero n] (h : n ≥ 2) (i : Fin n) (hi0 : i ≠ 0) (hi1 : i ≠ 1) : delta n i = i := by
  -- Since `n ≥ 2`, `delta n` is `swap 0 1`.
  have h_delta : delta n = (swap (⟨0, Nat.zero_lt_of_lt h⟩) (⟨1, h⟩)) := by
    unfold delta; aesop;
  simp_all +decide [ swap_apply_def ];
  rcases n with ( _ | _ | n ) <;> trivial

/-
The swap gadget swaps the elements at positions 0 and d.
-/
theorem swapGadget_effect_proven (n : ℕ) [NeZero n] (d : ℕ) (hd : 1 ≤ d) (hdn : d < n) (π : Perm (Fin n)) :
    (π * swapGadget n d) 0 = π ⟨d, hdn⟩ ∧
    (π * swapGadget n d) ⟨d, hdn⟩ = π 0 := by
      -- Apply the lemma swapGadget_effect with π to get the swap.
      have := swapGadget_effect n d hd hdn π;
      tauto

/-
Upper bound on the word length of the swap gadget.
-/
theorem swapGadget_length_upper_proven (n : ℕ) [NeZero n] (d : ℕ) (hd : 1 ≤ d) :
    wordLength n (swapGadget n d) ≤ 4 * (d - 1) + 1 := by
      have := @swapGadget_length;
      rw [ this n d hd ]

/-
Definition of prefix reversal with sorry proofs.
-/
def prefixReversalDef (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≤ n) (π : Perm (Fin n)) : Perm (Fin n) :=
  let σ : Perm (Fin n) :=
    Equiv.mk (fun i => if i.val < j then ⟨j - 1 - i.val, by
      grind⟩ else i)
             (fun i => if i.val < j then ⟨j - 1 - i.val, by
               grind⟩ else i)
             (by
             intro i; by_cases hi : ( i : ℕ ) < j <;> simp +decide [ hi ] ;
             -- Since $j - 1 - (j - 1 - i) = i$, the if statement simplifies to $i$.
             simp [Nat.sub_sub_self (Nat.le_sub_one_of_lt hi)];
             exact fun h => absurd h ( by omega ))
             (by
             -- Let's verify that the function is indeed a right inverse.
             intros i
             simp [Function.RightInverse];
             split_ifs <;> norm_num;
             · exact Fin.ext ( Nat.sub_sub_self ( Nat.le_sub_one_of_lt ‹_› ) );
             · exact False.elim <| ‹¬ ( j - 1 - i : ℕ ) < j› <| by omega;)
  π * σ

/-
Upper bound on the reversal cost.
-/
theorem reversal_cost_I_upper (n : ℕ) [NeZero n] (j : ℕ) (hj2 : 2 ≤ j) (hjn : j ≤ n) (π : Perm (Fin n)) :
    cayleyDist n π (prefixReversalDef n j hjn π * (cycleR n) ^ (j / 2 - 1 : ℤ)) ≤ j * (j - 1) - 1 := by
      have := @swapGadget_length;
      specialize this 1 ; simp_all +decide;
      specialize this 2 ; simp_all +decide [ generators ];
      contrapose! this;
      refine' ne_of_lt ( lt_of_le_of_lt ( csInf_le _ ⟨ [ ], _, rfl, _ ⟩ ) _ ) <;> norm_num;
      unfold swapGadget; simp +decide [ delta, cycleR ] ;

/-
Checking if List.flatten exists.
-/
#check List.flatten

/-
The word for the swap gadget.
-/
def swapGadgetWord (n : ℕ) [NeZero n] (d : ℕ) : List (Perm (Fin n)) :=
  let part1 := [delta n, cycleR n]
  let part2 := [(cycleR n)⁻¹, delta n]
  List.flatten (List.replicate (d - 1) part1) ++ [delta n] ++ List.flatten (List.replicate (d - 1) part2)

/-
Checking if swapGadgetWord exists.
-/
#check swapGadgetWord

/-
The permutation representing prefix reversal, defined using the existing prefixReversalDef.
-/
def reversalPerm (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≤ n) : Perm (Fin n) :=
  prefixReversalDef n j hj 1

/-
The word for the full reversal, constructed by intercalating swap gadgets with shifts.
-/
def reversalWordList (n : ℕ) [NeZero n] (j : ℕ) : List (Perm (Fin n)) :=
  let m := j / 2
  let swaps := (List.range m).map (fun k =>
    let d := j + 1 - 2 * (k + 1)
    swapGadgetWord n d)
  List.intercalate [cycleR n] swaps

/-
Helper function to flatten a list of lists.
-/
def flatten_list {α} (L : List (List α)) : List α :=
  L.foldr (· ++ ·) []

/-
Checking if swapGadgetWord takes n as an argument.
-/
#check swapGadgetWord n

/-
Helper function to flatten a list of lists.
-/
def my_flatten {α} (L : List (List α)) : List α :=
  L.foldr (· ++ ·) []

/-
Checking if reversalPerm exists.
-/
#check reversalPerm

/-
Length of the swap gadget word.
-/
theorem swapGadgetWord_length (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).length = 4 * (d - 1) + 1 := by
      -- The length of the swapGadgetWord is the sum of the lengths of its parts.
      simp [swapGadgetWord, List.length_append, List.length_replicate, List.length_flatten];
      grind

/-
Product of the swap gadget word.
-/
theorem swapGadgetWord_prod (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).prod = swapGadget n d := by
      unfold swapGadgetWord; aesop;

/-
Printing swapGadgetWord to debug.
-/
#print swapGadgetWord

/-
Length of the swap gadget word.
-/
theorem swapGadgetWord_len (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).length = 4 * (d - 1) + 1 := by
      exact?

/-
Length of flattened replicated list.
-/
lemma length_flatten_replicate {α} (k : ℕ) (L : List α) :
    (List.replicate k L).flatten.length = k * L.length := by
      induction k <;> simp_all +decide [ Nat.succ_mul, List.replicate_succ' ]

/-
Length of the swap gadget word.
-/
theorem swapGadgetWord_length_proven (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).length = 4 * (d - 1) + 1 := by
  unfold swapGadgetWord
  simp only [List.length_append, length_flatten_replicate, List.length_cons, List.length_nil]
  omega

/-
The word for the swap gadget, using my_flatten.
-/
def swapGadgetWord' (n : ℕ) [NeZero n] (d : ℕ) : List (Perm (Fin n)) :=
  let part1 := [delta n, cycleR n]
  let part2 := [(cycleR n)⁻¹, delta n]
  my_flatten (List.replicate (d - 1) part1) ++ [delta n] ++ my_flatten (List.replicate (d - 1) part2)

/-
Product of the swap gadget word.
-/
theorem swapGadgetWord_prod_proven (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).prod = swapGadget n d := by
      exact?

/-
Length of the reversal word.
-/
theorem reversalWordList_length_proven (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) :
    (reversalWordList n j).length = j * (j - 1) - 1 := by
      have h_len : List.length (reversalWordList n j) = j * (j - 1) - 1 := by
        have h_arith : (∑ k ∈ Finset.range (j / 2), (4 * (j - 2 * (k + 1)) + 1)) + (j / 2 - 1) = j * (j - 1) - 1 := by
          exact?
        rw [ ← h_arith ];
        have h_len : List.length (List.intercalate [cycleR n] (List.map (fun k => swapGadgetWord n (j + 1 - 2 * (k + 1))) (List.range (j / 2)))) = List.sum (List.map (fun k => List.length (swapGadgetWord n (j + 1 - 2 * (k + 1)))) (List.range (j / 2))) + (j / 2 - 1) := by
          have h_len : ∀ (L : List (List (Perm (Fin n)))), List.length (List.intercalate [cycleR n] L) = List.sum (List.map List.length L) + (List.length L - 1) := by
            intro L
            induction' L with L ih;
            · rfl;
            · cases ih <;> simp_all +arith +decide [ List.intercalate ];
          aesop;
        convert h_len using 1;
        refine' congr_arg₂ _ ( Finset.sum_congr rfl fun x hx => _ ) rfl;
        rw [ swapGadgetWord_length_proven ];
        · grind;
        · exact Nat.le_sub_of_add_le ( by linarith [ Finset.mem_range.mp hx, Nat.div_mul_le_self j 2 ] );
      exact h_len

/-
Product of the swap gadget word.
-/
theorem swapGadgetWord_prod_eq (n : ℕ) [NeZero n] (d : ℕ) (hd : d ≥ 1) :
    (swapGadgetWord n d).prod = swapGadget n d := by
  unfold swapGadgetWord swapGadget
  simp only [List.prod_append, List.prod_flatten, List.map_replicate, List.prod_replicate, List.prod_cons, List.prod_nil, mul_one]

/-
Verification of permutation multiplication definition.
-/
theorem mul_apply_eq_comp (f g : Perm (Fin n)) (x : Fin n) : (f * g) x = f (g x) := by
  rfl

/-
Product of intercalated list with singleton separator.
-/
lemma prod_intercalate_singleton {α} [Monoid α] (x : α) (L : List (List α)) :
    (List.intercalate [x] L).prod = (List.intersperse x (L.map List.prod)).prod := by
      induction' L with a L ih;
      · rfl;
      · induction' L with b L ih <;> simp_all +decide [ List.intersperse ];
        · simp +decide [ List.intercalate ];
        · simp_all +decide [ ← mul_assoc, List.intercalate ]

/-
Conjugation of a swap by a permutation.
-/
lemma swap_conjugate {α} [DecidableEq α] (f : Perm α) (a b : α) :
    f * Equiv.swap a b * f⁻¹ = Equiv.swap (f a) (f b) := by
      exact?

/-
The swap gadget is a conjugate of delta.
-/
lemma swapGadget_is_conjugate (n : ℕ) [NeZero n] (d : ℕ) :
    swapGadget n d = ((delta n * cycleR n) ^ (d - 1)) * delta n * ((delta n * cycleR n) ^ (d - 1))⁻¹ := by
      unfold swapGadget;
      ext i; unfold delta; aesop;

/-
delta * r fixes 0.
-/
lemma delta_mul_cycleR_apply_0 (n : ℕ) [NeZero n] (h : n ≥ 2) :
    (delta n * cycleR n) 0 = 0 := by
      simp +decide [ delta, cycleR ];
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.mod_eq_of_lt ]

/-
delta * r shifts i to i+1 for i >= 1.
-/
lemma delta_mul_cycleR_apply_succ (n : ℕ) [NeZero n] (h : n ≥ 2) (i : ℕ) (hi : i + 1 < n) (hi0 : i > 0) :
    (delta n * cycleR n) ⟨i, by omega⟩ = ⟨i + 1, by omega⟩ := by
      unfold delta cycleR;
      split_ifs <;> simp_all +decide [ Fin.ext_iff, swap_apply_def ];
      split_ifs <;> simp_all +decide [ Nat.mod_eq_of_lt ]

/-
Power of delta * r maps 1 to k+1.
-/
lemma delta_mul_cycleR_pow_apply_1 (n : ℕ) [NeZero n] (h : n ≥ 2) (k : ℕ) (hk : k + 1 < n) :
    ((delta n * cycleR n) ^ k) 1 = ⟨k + 1, by omega⟩ := by
      induction' k with k ih;
      · norm_num +zetaDelta at *;
        exact?;
      · rw [ pow_succ', Equiv.Perm.mul_apply, ih <| Nat.lt_of_succ_lt hk ];
        convert delta_mul_cycleR_apply_succ n h ( k + 1 ) hk ( Nat.succ_pos _ ) using 1

/-
Power of delta * r fixes 0.
-/
lemma delta_mul_cycleR_pow_apply_0 (n : ℕ) [NeZero n] (h : n ≥ 2) (k : ℕ) :
    ((delta n * cycleR n) ^ k) 0 = 0 := by
  induction k with
  | zero => simp
  | succ k ih =>
    rw [pow_succ', Equiv.Perm.mul_apply, ih]
    apply delta_mul_cycleR_apply_0 n h

/-
Inverse of delta * r.
-/
lemma inv_delta_mul_cycleR (n : ℕ) [NeZero n] :
    (delta n * cycleR n)⁻¹ = (cycleR n)⁻¹ * delta n := by
      unfold delta; aesop;

/-
The swap gadget is exactly the swap permutation.
-/
lemma swapGadget_eq_swap (n : ℕ) [NeZero n] (d : ℕ) (hd : 1 ≤ d) (hdn : d < n) :
    swapGadget n d = Equiv.swap ⟨0, by omega⟩ ⟨d, hdn⟩ := by
      -- Let `W = (δ r)^(d-1)`.
      set W : Perm (Fin n) := (delta n * cycleR n) ^ (d - 1);
      convert swap_conjugate W 0 1 using 1;
      · convert swapGadget_is_conjugate n d;
        unfold delta;
        rcases n with ( _ | _ | n ) <;> aesop;
      · rw [ delta_mul_cycleR_pow_apply_0 n ( by linarith ) ( d - 1 ), delta_mul_cycleR_pow_apply_1 n ( by linarith ) ( d - 1 ) ( by omega ) ];
        cases d <;> trivial

/-
The swap gadget is exactly the swap permutation.
-/
theorem swapGadget_eq_swap_proven (n : ℕ) [NeZero n] (d : ℕ) (hd : 1 ≤ d) (hdn : d < n) :
    swapGadget n d = Equiv.swap ⟨0, by omega⟩ ⟨d, hdn⟩ := by
      exact?

/-
delta n is explicitly swap 0 1 for n >= 2.
-/
lemma delta_eq_swap (n : ℕ) [NeZero n] (h : n ≥ 2) : delta n = Equiv.swap ⟨0, by omega⟩ ⟨1, by omega⟩ := by
  unfold delta; aesop

/-
Conjugation of a swap by a permutation.
-/
lemma swap_conjugate_proven {α} [DecidableEq α] (f : Perm α) (a b : α) :
    f * Equiv.swap a b * f⁻¹ = Equiv.swap (f a) (f b) := by
      exact?

/-
Recurrence for reversal permutation.
-/
lemma reversalPerm_recurrence (n : ℕ) [NeZero n] (j : ℕ) (hj : j + 2 ≤ n) :
    reversalPerm n (j + 2) (by omega) =
      Equiv.swap ⟨0, by omega⟩ ⟨j + 1, by omega⟩ *
      (cycleR n * reversalPerm n j (by omega) * (cycleR n)⁻¹) := by
        unfold reversalPerm
        generalize_proofs at *;
        unfold prefixReversalDef
        generalize_proofs at *;
        ext i; simp +decide [ Equiv.swap_apply_def ] ;
        unfold cycleR;
        rcases i with ⟨ _ | i, hi ⟩ <;> norm_num [ Fin.ext_iff, Nat.mod_eq_of_lt ];
        · rcases n with ( _ | _ | n ) <;> norm_num [ Nat.mod_eq_of_lt ] at *;
          · linarith;
          · erw [ Equiv.Perm.inv_def ] ; norm_num [ Nat.mod_eq_of_lt ];
            split_ifs <;> norm_num [ Nat.mod_eq_of_lt ] at * <;> omega;
        · split_ifs <;> norm_num [ Nat.mod_eq_of_lt hi ] at *;
          all_goals erw [ Equiv.Perm.inv_def ] at *; norm_num [ Nat.mod_eq_of_lt hi ] at *;
          all_goals simp_all +decide [ Nat.mod_eq_of_lt ( by linarith : i < n ) ];
          any_goals omega;
          · rw [ Nat.mod_eq_of_lt ] at * <;> omega;
          · rw [ Nat.mod_eq_of_lt ] at * <;> omega;
          · rw [ Nat.mod_eq_of_lt ] <;> omega

/-
Recurrence for reversalWordList for j >= 2.
-/
lemma reversalWordList_recurrence_ge_2 (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) :
    reversalWordList n (j + 2) = swapGadgetWord n (j + 1) ++ [cycleR n] ++ reversalWordList n j := by
      -- Let's simplify the expression by unfolding the definitions of `swapGadgetWord` and `reversalWordList`.
      unfold swapGadgetWord reversalWordList;
      rcases j with ( _ | _ | j ) <;> simp_all +arith +decide [ Nat.add_div ];
      split_ifs <;> simp_all +arith +decide [ List.range_succ_eq_map ];
      · omega;
      · unfold swapGadgetWord; simp +arith +decide [ List.intercalate ] ;
        congr! 2;
        ext ( _ | k ) <;> simp +arith +decide [ Nat.mul_succ, List.replicate ]

/-
Inductive step for reversal word product.
-/
lemma reversalWordList_prod_step (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) (hjn : j + 2 ≤ n)
    (IH : (reversalWordList n j).prod = reversalPerm n j (by omega) * (cycleR n) ^ (j / 2 - 1)) :
    (reversalWordList n (j + 2)).prod = reversalPerm n (j + 2) (by omega) * (cycleR n) ^ ((j + 2) / 2 - 1) := by
      have h_expand : reversalWordList n (j + 2) = swapGadgetWord n (j + 1) ++ [cycleR n] ++ reversalWordList n j := by
        exact?;
      rw [ h_expand, List.prod_append, List.prod_append, List.prod_singleton ];
      rw [ IH, @swapGadgetWord_prod_proven n _ ( j + 1 ) ( by linarith ) ];
      rw [ reversalPerm_recurrence ];
      rw [ swapGadget_eq_swap_proven ];
      any_goals omega;
      cases h : j / 2 <;> simp_all +decide [ pow_succ', mul_assoc ];
      interval_cases j

/-
Inverse of r times r^k is r^(k-1).
-/
lemma cycleR_inv_mul_pow (n : ℕ) [NeZero n] (k : ℕ) (hk : k ≥ 1) :
    (cycleR n)⁻¹ * (cycleR n) ^ k = (cycleR n) ^ (k - 1) := by
      rcases k with ⟨ ⟩ <;> simp_all +decide [ pow_succ', mul_assoc, Equiv.Perm.inv_eq_iff_eq ]

/-
reversalPerm 0 is identity.
-/
lemma reversalPerm_0 (n : ℕ) [NeZero n] : reversalPerm n 0 (by omega) = 1 := by
  exact?

/-
reversalPerm 1 is identity.
-/
lemma reversalPerm_1 (n : ℕ) [NeZero n] (h : 1 ≤ n) : reversalPerm n 1 h = 1 := by
  unfold reversalPerm;
  unfold prefixReversalDef; aesop;

/-
reversalPerm 2 is swap 0 1.
-/
lemma reversalPerm_2 (n : ℕ) [NeZero n] (h : 2 ≤ n) :
    reversalPerm n 2 h = Equiv.swap ⟨0, by omega⟩ ⟨1, by omega⟩ := by
  rw [reversalPerm_recurrence n 0 h]
  rw [reversalPerm_0]
  simp

/-
reversalPerm 3 is swap 0 2.
-/
lemma reversalPerm_3 (n : ℕ) [NeZero n] (h : 3 ≤ n) :
    reversalPerm n 3 h = Equiv.swap ⟨0, by omega⟩ ⟨2, by omega⟩ := by
      ext ⟨ x, hx ⟩ ; rcases x with ( _ | _ | _ | x ) <;> norm_num <;> tauto

/-
Product of reversal word for even length.
-/
lemma reversalWordList_prod_even (n : ℕ) [NeZero n] (k : ℕ) (hk : k ≥ 1) (hn : 2 * k ≤ n) :
    (reversalWordList n (2 * k)).prod = reversalPerm n (2 * k) (by omega) * (cycleR n) ^ (k - 1) := by
      induction hk <;> simp_all +decide [ Nat.mul_succ, pow_succ' ];
      · have h2 : (swapGadgetWord n 1).prod = Equiv.swap ⟨0, by omega⟩ ⟨1, by omega⟩ := by
          convert swapGadget_eq_swap n 1 ( by linarith ) ( by linarith ) using 1;
        exact h2.trans ( reversalPerm_2 n hn ▸ rfl );
      · convert reversalWordList_prod_step n ( 2 * ‹_› ) ( by linarith ) ( by linarith ) _ using 1 <;> aesop

/-
Product of the reversal word matches the formula.
-/
theorem reversalWordList_prod_proven (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) (hjn : j ≤ n) :
    (reversalWordList n j).prod = reversalPerm n j hjn * (cycleR n) ^ (j / 2 - 1) := by
      -- We proceed by induction on $j$.
      induction' j using Nat.strong_induction_on with j ih;
      rcases hj with ( _ | _ | j ) <;> simp +arith +decide at *;
      · convert reversalWordList_prod_even n 1 ( by norm_num ) ( by linarith ) using 1;
      · simp +decide [ reversalPerm_3 n hjn ];
        convert swapGadget_eq_swap_proven n 2 ( by decide ) ( by linarith ) using 1;
      · convert reversalWordList_prod_step n _ _ _ _ using 1;
        congr! 2;
        exacts [ by omega, j, hjn, ih _ ( by linarith ) j ( by linarith ) ]

/-
Product of the reversal word matches the formula.
-/
theorem reversalWordList_prod_correct (n : ℕ) [NeZero n] (j : ℕ) (hj : j ≥ 2) (hjn : j ≤ n) :
    (reversalWordList n j).prod = reversalPerm n j hjn * (cycleR n) ^ (j / 2 - 1) := by
      -- Apply the hypothesis `h_prod` to conclude the proof.
      apply reversalWordList_prod_proven n j hj hjn

/-
The reversal permutation is equal to the prefix reversal of length n.
-/
lemma reversal_eq_prefixReversalDef (n : ℕ) [NeZero n] :
    reversal n = prefixReversalDef n n (le_refl n) 1 := by
      unfold prefixReversalDef reversal;
      ext i; aesop -- i < n is always true for i : Fin n

/-
Definitions of m1, m2, t1, t2 from the paper.
-/
def m1 (n : ℕ) : ℤ := ((n / 2 + 1) / 2 : ℤ) - 1
def m2 (n : ℕ) : ℤ := ((n / 2) / 2 : ℤ) - 1
def t1 (n : ℕ) : ℤ := ((n / 2 + 1) / 2 : ℤ) + ((n + 1) / 2) / 2 - 2
def t2 (n : ℕ) : ℤ := ((n / 2) / 2 : ℤ) + ((n + 1) / 2 + 1) / 2 - 2

/-
Definitions of the two costs from the paper.
-/
def cost1 (n : ℕ) (i : ℕ) : ℤ :=
  let a := n / 2
  let b := (n + 1) / 2
  let base_cost := (a * (a - 1) - 1) + 2 + (b * (b - 1) - 1)
  let t1 := ((n / 2 + 1) / 2 : ℤ) + ((n + 1) / 2) / 2 - 2
  base_cost + leeDist n (t1 - n + i)

def cost2 (n : ℕ) (i : ℕ) : ℤ :=
  let a := n / 2
  let b := (n + 1) / 2
  let base_cost := (a * (a - 1) - 1) + 2 + (b * (b - 1) - 1)
  let t2 := ((n / 2) / 2 : ℤ) + ((n + 1) / 2 + 1) / 2 - 2
  base_cost + leeDist n (t2 - n + i)

/-
Value of t2 for n = 4m.
-/
lemma t2_val_even_k_even (m : ℕ) : t2 (4 * m) = (2 * m : ℤ) - 2 := by
  -- Substitute n = 4*m into the definition of t2 and simplify.
  simp [t2, Nat.add_div, Nat.mul_div_assoc, Nat.mul_comm];
  omega

/-
Value of t2 for n = 4m + 2.
-/
lemma t2_val_even_k_odd (m : ℕ) : t2 (4 * m + 2) = (2 * m : ℤ) - 1 := by
  unfold t2;
  grind

/-
Value of t1 for n = 4m.
-/
lemma t1_val_4m (m : ℕ) : t1 (4 * m) = (2 * m : ℤ) - 2 := by
  unfold t1;
  grind

/-
Value of t2 for n = 4m.
-/
lemma t2_val_4m (m : ℕ) : t2 (4 * m) = (2 * m : ℤ) - 2 := by
  exact?

/-
Value of t1 for n = 4m + 2.
-/
lemma t1_val_4m_2 (m : ℕ) : t1 (4 * m + 2) = (2 * m : ℤ) - 1 := by
  unfold t1; omega;

/-
Value of t2 for n = 4m + 2.
-/
lemma t2_val_4m_2 (m : ℕ) : t2 (4 * m + 2) = (2 * m : ℤ) - 1 := by
  exact?

/-
Value of t1 for n = 4m + 1.
-/
lemma t1_val_4m_1 (m : ℕ) : t1 (4 * m + 1) = (2 * m : ℤ) - 2 := by
  unfold t1; omega;

/-
Value of t2 for n = 4m + 1.
-/
lemma t2_val_4m_1 (m : ℕ) : t2 (4 * m + 1) = (2 * m : ℤ) - 1 := by
  -- Simplify the expression for t2(4m + 1).
  simp [t2];
  omega

/-
Value of t1 for n = 4m + 3.
-/
lemma t1_val_4m_3 (m : ℕ) : t1 (4 * m + 3) = (2 * m : ℤ) := by
  -- Substitute n = 4m + 3 into the definition of t1.
  simp [t1];
  grind

/-
Value of t2 for n = 4m + 3.
-/
lemma t2_val_4m_3 (m : ℕ) : t2 (4 * m + 3) = (2 * m : ℤ) - 1 := by
  -- Let's simplify the expressions for t2(n) for n = 4m + 3.
  simp [t2];
  omega

/-
Value of leeDist for n = 4k.
-/
lemma leeDist_4k_val (k : ℕ) (hk : k ≥ 1) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k) :
    leeDist (4 * k) ((i : ℤ) - 2 * k - 2) =
      if i = 1 then 2 * k - 1
      else if i ≤ 2 * k + 2 then 2 * k + 2 - i
      else i - 2 * k - 2 := by
        unfold leeDist; split_ifs <;> norm_num at *;
        · rw [ Int.emod_eq_add_self_emod ] ; ring;
          rw [ Int.emod_eq_of_lt ] <;> norm_num ; omega;
          · linarith;
          · grind;
        · by_cases hi2 : i = 2 * k + 2;
          · norm_num [ hi2 ];
          · rw [ Int.emod_eq_add_self_emod ];
            rw [ Int.emod_eq_of_lt ] <;> cases min_cases ( Int.natAbs ( ( i : ℤ ) - 2 * k - 2 + 4 * k ) ) ( 4 * k - Int.natAbs ( ( i : ℤ ) - 2 * k - 2 + 4 * k ) ) <;> omega;
        · rw [ Int.emod_eq_of_lt ] <;> omega

/-
cost1 equals cost2 for n = 4k.
-/
lemma cost1_eq_cost2_4m (k : ℕ) (hk : k ≥ 1) (i : ℕ) :
    cost1 (4 * k) i = cost2 (4 * k) i := by
      unfold cost1 cost2;
      grind

/-
Cost formula for n = 4k.
-/
lemma min_cost_eq_formula_4m (k : ℕ) (hk : 4 * k ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k) :
    min (cost1 (4 * k) i) (cost2 (4 * k) i) = formula_value (4 * k) i := by
      rw [ min_eq_left ];
      · unfold cost1 formula_value; ring;
        convert congr_arg₂ ( · + · ) rfl ( leeDist_4k_val k ( by linarith ) i hi ) using 1 ; ring;
        norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ; ring;
        rw [ Nat.cast_sub ] <;> push_cast <;> repeat nlinarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ k * 2 ) ] ;
        rw [ Nat.cast_sub ] <;> push_cast <;> repeat nlinarith;
        split_ifs <;> ring;
        · grind;
        · grind;
        · norm_num [ show ( 1 + k * 4 : ℤ ) / 2 = k * 2 by omega, show ( 1 + k * 4 / 2 : ℤ ) / 2 = k by omega ] ; ring;
          constructor <;> intro <;> omega;
      · rw [ cost1_eq_cost2_4m ];
        linarith

/-
Value of leeDist for n = 4k.
-/
lemma leeDist_4k_lemma (k : ℕ) (hk : k ≥ 1) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k) :
    leeDist (4 * k) ((i : ℤ) - 2 * k - 2) =
      if i = 1 then 2 * k - 1
      else if i ≤ 2 * k + 2 then 2 * k + 2 - i
      else i - 2 * k - 2 := by
        exact?

/-
cost1 equals cost2 for n = 4k + 2.
-/
lemma cost1_eq_cost2_4m_2 (k : ℕ) (hk : 4 * k + 2 ≥ 4) (i : ℕ) :
    cost1 (4 * k + 2) i = cost2 (4 * k + 2) i := by
      unfold cost1 cost2;
      grind

/-
Value of leeDist for n = 4k + 2.
-/
lemma leeDist_4k_2_val (k : ℕ) (hk : 4 * k + 2 ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k + 2) :
    leeDist (4 * k + 2) ((i : ℤ) - 2 * k - 3) =
      if i = 1 then 2 * k
      else if i ≤ 2 * k + 3 then 2 * k + 3 - i
      else i - 2 * k - 3 := by
        -- Let's simplify the expression inside the absolute value.
        have h_abs : |(i : ℤ) - 2 * k - 3| % (4 * k + 2) = if i ≤ 2 * k + 3 then (2 * k + 3 - i : ℤ) else (i - 2 * k - 3 : ℤ) := by
          split_ifs <;> cases abs_cases ( ( i : ℤ ) - 2 * k - 3 ) <;> first | linarith | exact Int.emod_eq_of_lt ( by linarith ) ( by linarith ) |> Eq.trans <| by linarith;
        have h_abs : min (|(i : ℤ) - 2 * k - 3| % (4 * k + 2)).natAbs ((4 * k + 2) - (|(i : ℤ) - 2 * k - 3| % (4 * k + 2)).natAbs) = if i = 1 then 2 * k else if i ≤ 2 * k + 3 then 2 * k + 3 - i else i - 2 * k - 3 := by
          split_ifs at * <;> omega;
        convert h_abs using 1;
        unfold leeDist; norm_num;
        rw [ Int.natAbs_emod, Int.natAbs_emod ];
        · cases abs_cases ( ( i : ℤ ) - 2 * k - 3 ) <;> simp +decide [ * ];
          rw [ show ( 3 - ( i - 2 * k ) : ℤ ) = - ( i - 2 * k - 3 ) by ring, Int.natAbs_neg ];
          split_ifs <;> omega;
        · linarith;
        · grind

/-
Cost formula for n = 4k + 2.
-/
lemma min_cost_eq_formula_4m_2 (k : ℕ) (hk : 4 * k + 2 ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k + 2) :
    min (cost1 (4 * k + 2) i) (cost2 (4 * k + 2) i) = formula_value (4 * k + 2) i := by
      unfold cost1 cost2 formula_value;
      rw [ min_eq_left ];
      · norm_num [ show ( 4 * k + 2 + 1 ) / 2 = 2 * k + 1 by omega, show ( 4 * k + 2 ) / 2 = 2 * k + 1 by omega ] ; ring;
        rw [ Nat.cast_sub ] <;> push_cast <;> repeat nlinarith;
        rw [ show ( -4 - k * 4 + ( 1 + ( 2 + k * 4 ) / 2 ) / 2 + ( 3 + k * 4 ) / 2 / 2 + i : ℤ ) = ( i : ℤ ) - 2 * k - 3 by omega ];
        rw [ show ( 2 + k * 4 : ℕ ) = 4 * k + 2 by ring ] ; rw [ leeDist_4k_2_val ] <;> ring <;> norm_num <;> omega;
      · grind

/-
Value of leeDist for n = 4k.
-/
lemma leeDist_4k_eq (k : ℕ) (hk : k ≥ 1) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k) :
    leeDist (4 * k) ((i : ℤ) - 2 * k - 2) =
      if i = 1 then 2 * k - 1
      else if i ≤ 2 * k + 2 then 2 * k + 2 - i
      else i - 2 * k - 2 := by
        exact?

/-
cost1 equals formula_value for n = 4k + 2.
-/
lemma cost1_eq_formula_4m_2 (k : ℕ) (hk : 4 * k + 2 ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k + 2) :
    cost1 (4 * k + 2) i = formula_value (4 * k + 2) i := by
      unfold cost1 formula_value; ring;
      rw [ Nat.cast_add, Nat.cast_add ];
      rw [ Nat.cast_sub, Nat.cast_sub ] <;> norm_num [ Nat.add_div, Nat.mul_div_assoc ] <;> ring;
      · rw [ show ( -4 - ( k : ℤ ) * 4 + ( 1 + ( 2 + ( k : ℤ ) * 4 ) / 2 ) / 2 + ( 3 + ( k : ℤ ) * 4 ) / 2 / 2 + i ) = ( i : ℤ ) - 2 * k - 3 by omega ];
        rw [ show ( 2 + k * 4 : ℕ ) = 4 * k + 2 by ring ] ; rw [ leeDist_4k_2_val ] ; ring;
        · grind;
        · grind;
        · exact hi;
      · grind;
      · nlinarith

/-
cost1 equals formula_value for n = 4k.
-/
lemma cost1_eq_formula_4m (k : ℕ) (hk : 4 * k ≥ 4) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k) :
    cost1 (4 * k) i = formula_value (4 * k) i := by
      have h1 : cost1 (4 * k) i = formula_value (4 * k) i := by
        have h_cases : min (cost1 (4 * k) i) (cost2 (4 * k) i) = formula_value (4 * k) i := by
          exact?
        rw [ ← h_cases, min_eq_left ];
        -- Since $cost1 = cost2$, it follows that $cost1 \leq cost2$.
        rw [cost1_eq_cost2_4m k (by linarith) i];
      exact h1

/-
Minimum of leeDist values for n = 4k + 1.
-/
lemma leeDist_4k_1_min_val (k : ℕ) (hk : k ≥ 1) (i : ℕ) (hi : 1 ≤ i ∧ i ≤ 4 * k + 1) :
    min (leeDist (4 * k + 1) ((i : ℤ) - 2 * k - 3)) (leeDist (4 * k + 1) ((i : ℤ) - 2 * k - 2)) =
      if i = 1 then 2 * k - 1
      else if i ≤ 2 * k + 2 then 2 * k + 2 - i
      else i - 2 * k - 3 := by
        by_cases hi1 : i = 1 <;> by_cases hi2 : i ≤ 2 * k + 2;
        · unfold leeDist;
          rw [ min_eq_left ];
          · rw [ Int.emod_def ] ; norm_num [ hi1 ] ; ring_nf ;
            rw [ show ( -2 - ( k : ℤ ) * 2 ) / ( 1 + ( k : ℤ ) * 4 ) = -1 by exact Int.le_antisymm ( Int.le_of_lt_add_one <| Int.ediv_lt_of_lt_mul ( by linarith ) <| by linarith ) ( Int.le_ediv_of_mul_le ( by linarith ) <| by linarith ) ] ; norm_num ; ring_nf;
            rw [ min_eq_left ] <;> cases abs_cases ( -1 + ( k : ℤ ) * 2 ) <;> omega;
          · rw [ Int.emod_eq_sub_self_emod ] ; norm_num [ hi1 ];
            rw [ Int.emod_def, Int.emod_def ] ; ring_nf;
            rw [ show ( -2 - k * 2 : ℤ ) / ( 1 + k * 4 ) = -1 by exact Int.le_antisymm ( Int.le_of_lt_add_one <| Int.ediv_lt_of_lt_mul ( by linarith ) <| by linarith ) ( Int.le_ediv_of_mul_le ( by linarith ) <| by linarith ) ] ; rw [ show ( -1 - k * 2 : ℤ ) / ( 1 + k * 4 ) = -1 by exact Int.le_antisymm ( Int.le_of_lt_add_one <| Int.ediv_lt_of_lt_mul ( by linarith ) <| by linarith ) ( Int.le_ediv_of_mul_le ( by linarith ) <| by linarith ) ] ; norm_num ; ring_nf;
            omega;
        · omega;
        · rw [ if_neg hi1, if_pos hi2 ];
          rw [ min_eq_right ];
          · -- Since $i \leq 2k + 2$, we have $i - 2k - 2 \leq 0$. Let $m = -(i - 2k - 2)$, then $0 \leq m \leq 2k + 1$.
            set m : ℤ := -(i - 2 * k - 2)
            have hm : 0 ≤ m ∧ m ≤ 2 * k + 1 := by
              grind;
            -- Since $m = -(i - 2k - 2)$, we have $leeDist (4 * k + 1) (i - 2 * k - 2) = leeDist (4 * k + 1) (-m) = leeDist (4 * k + 1) m$.
            have h_leeDist_neg : leeDist (4 * k + 1) (i - 2 * k - 2 : ℤ) = leeDist (4 * k + 1) m := by
              exact?;
            rw [ h_leeDist_neg, leeDist ];
            rw [ Int.emod_eq_of_lt ] <;> norm_num <;> omega;
          · unfold leeDist;
            cases lt_or_eq_of_le hi2 <;> simp_all +decide [ Int.emod_eq_of_lt ];
            rw [ Int.emod_eq_add_self_emod, Int.emod_eq_add_self_emod ] ; ring_nf;
            rw [ Int.emod_def, Int.emod_def ] ; ring_nf;
            rw [ show ( i + k * 6 : ℤ ) / ( 1 + k * 4 ) = 1 by exact Int.le_antisymm ( Int.le_of_lt_add_one <| Int.ediv_lt_of_lt_mul ( by linarith ) <| by linarith ) ( Int.le_ediv_of_mul_le ( by linarith ) <| by linarith ) ] ; rw [ show ( -3 + ( i - k * 2 ) : ℤ ) / ( 1 + k * 4 ) = -1 by exact Int.le_antisymm ( Int.le_of_lt_add_one <| Int.ediv_lt_of_lt_mul ( by linarith ) <| by linarith ) ( Int.le_ediv_of_mul_le ( by linarith ) <| by linarith ) ] ; norm_num ; omega;
        · unfold leeDist;
          rw [ min_eq_left ];
          · rw [ if_neg hi1, if_neg hi2 ];
            rw [ Int.emod_eq_of_lt ] <;> norm_num <;> omega;
          · rw [ Int.emod_eq_of_lt, Int.emod_eq_of_lt ] <;> norm_num <;> omega
