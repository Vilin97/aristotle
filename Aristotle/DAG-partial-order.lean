/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f3bf528a-7a65-44e9-be04-cc2da39410ac
-/

/-
We define a Directed Acyclic Graph (DAG) as a relation whose transitive closure is irreflexive. We then prove that the reflexive transitive closure of a DAG forms a partial order, and conversely, the strict order relation of any partial order forms a DAG. This establishes the equivalence between DAGs and partial orders.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking for IsStrictOrder
-/
#check IsStrictOrder

/-
Checking for IsPartialOrder
-/
#check IsPartialOrder

/-
A relation is a DAG if its transitive closure is irreflexive.
-/
def IsDAG {α : Type*} (r : α → α → Prop) : Prop :=
  IsIrrefl α (Relation.TransGen r)

/-
Checking definition of IsStrictOrder
-/
#print IsStrictOrder

/-
The reflexive transitive closure of a DAG is a partial order.
-/
theorem partialOrder_of_DAG {α : Type*} (r : α → α → Prop) (h : IsDAG r) :
    IsPartialOrder α (Relation.ReflTransGen r) := by
  refine' { .. };
  intro a b hab hba;
  -- If $a \neq b$, then we have a cycle in the transitive closure, contradicting IsDAG.
  by_contra h_neq
  have h_cycle : Relation.TransGen r a b ∧ Relation.TransGen r b a := by
    refine' ⟨ _, _ ⟩;
    · cases hab ; aesop;
      exact?;
    · cases hba ; aesop;
      exact?;
  exact h.1 a ( Relation.TransGen.trans h_cycle.1 h_cycle.2 )

/-
The strict order relation of a partial order is a DAG.
-/
theorem DAG_of_partialOrder {α : Type*} [PartialOrder α] : IsDAG (· < · : α → α → Prop) := by
  -- The strict order relation < on a partial order is a DAG because its transitive closure is itself, which is irreflexive.
  have h_trans_closure : Relation.TransGen (fun x y : α => x < y) = fun x y : α => x < y := by
    ext x y; exact ⟨fun h => by
      induction h <;> solve_by_elim [ lt_trans ], fun h => by
      exact Relation.TransGen.single h⟩;
  constructor ; intro x ; aesop